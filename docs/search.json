[
  {
    "objectID": "3_rust.html",
    "href": "3_rust.html",
    "title": "Validation & Visualization",
    "section": "",
    "text": "Identification of Rust Fungal Species through Metabarcoding and AODP"
  },
  {
    "objectID": "3_rust.html#load-r-packages-quietly",
    "href": "3_rust.html#load-r-packages-quietly",
    "title": "Validation & Visualization",
    "section": "Load R packages quietly",
    "text": "Load R packages quietly\n\n\n\n\n\n\nR Block\n\n\n\n\n# 1. Load packages quietly ----------------------------------------------------\nlibrary(phyloseq)    # handling phyloseq objects\nlibrary(dplyr)       # data manipulation\nlibrary(tidyr)       # data manipulation\nlibrary(tibble)      # data manipulation\nlibrary(stringr)     # string operations\nlibrary(msa)         # multiple sequence alignment\nlibrary(Biostrings)  # DNAStringSet I/O\nlibrary(phangorn)    # phylogeny inference\nlibrary(ape)         # NJ tree, plotting utilities\nlibrary(ggplot2)     # plotting\nlibrary(ggtree)      # tree plotting\nlibrary(ggmsa)       # alignment inset\nlibrary(treeio)      # rescale_tree()\n\nlibrary(purrr)      # functional programming toolkit\nlibrary(cowplot)    # add-on to ggplot\n\npackageVersion(\"phyloseq\")\n\n[1] '1.50.0'\n\npackageVersion(\"ggmsa\")\n\n[1] '1.13.1'"
  },
  {
    "objectID": "3_rust.html#validating-aodp-classification-via-phylogenetic-tree-reconstruction",
    "href": "3_rust.html#validating-aodp-classification-via-phylogenetic-tree-reconstruction",
    "title": "Validation & Visualization",
    "section": "Validating AODP classification via phylogenetic tree reconstruction",
    "text": "Validating AODP classification via phylogenetic tree reconstruction\n\n\n\n\n\n\nR Block\n\n\n\n\n# ──────────────────────────────────────────────────────────────────────────────\n#  Phylogenetic analysis of Puccinia striiformis s.l. (ML tree + alignment)\n# ──────────────────────────────────────────────────────────────────────────────\n\n# 1. Define target species & import phyloseq ---------------------------------\nPst_sl &lt;- c(\n  \"Puccinia_striiformis\",\n  \"Puccinia_pseudostriiformis\",\n  \"Puccinia_striiformoides\"\n)\n\nps &lt;- readRDS(\"output/phyloseq_rust_aodp.rds\")\n\n# 2. Extract representative ASV sequences with new labels --------------------\nps_sub &lt;- subset_taxa(ps, species %in% Pst_sl)\nrep_seqs &lt;- refseq(ps_sub)\nnew_ids &lt;- tax_table(ps_sub) %&gt;%\n  as.data.frame(stringsAsFactors=FALSE) %&gt;%\n  rownames_to_column(\"ASV\") %&gt;%\n  mutate(newID = paste(species, \"|\", ASV, sep=\"\")) %&gt;%\n  pull(newID)\nnames(rep_seqs) &lt;- new_ids\n\n# 3. Load reference DB (incl. outgroup) & rename ------------------------------\nref_db &lt;- readDNAStringSet(\"refDBs/CR-ITS2-refDB.fasta\")\npattern &lt;- paste(Pst_sl, collapse=\"|\")\nref_sel &lt;- ref_db[grepl(pattern, names(ref_db)) |\n                    grepl(\"HM131236\", names(ref_db))] \nref_ids &lt;- names(ref_sel) %&gt;%\n  strsplit(\"\\\\|\") %&gt;%\n  map_chr(~ paste(.x[1:2], collapse=\"|\"))\nnames(ref_sel) &lt;- ref_ids\n\n# 4. Combine sequences & run MUSCLE -------------------------------------------\nall_seqs   &lt;- c(ref_sel, rep_seqs)\naln        &lt;- msa(all_seqs, method=\"Muscle\", order=\"input\")\naln_plain  &lt;- unmasked(aln)              # DNAStringSet\nalign_file &lt;- \"output/Pst_sl_rep.ref_align.fasta\"\nwriteXStringSet(aln_plain, align_file)\n\n# 5. Build maximum‐likelihood tree --------------------------------------------\nphydat &lt;- as.phyDat(aln, type=\"DNA\")\ndm     &lt;- dist.ml(phydat)\nnj0    &lt;- NJ(dm)\nfit0   &lt;- pml(nj0, data=phydat) %&gt;%\n  update(k=4, inv=0.2) %&gt;%\n  optim.pml(\n    model        = \"GTR\",\n    optInv       = TRUE,\n    optGamma     = TRUE,\n    rearrangement= \"stochastic\",\n    control      = pml.control(trace=0)\n  )\nml_tree        &lt;- root(\n  fit0$tree,\n  outgroup     = \"Puccinia_coronati.brevispora|HM131236\",\n  resolve.root = TRUE\n)\n\n# 6. Plot the ML tree --------------------------------------------------------\np_tree &lt;- ggtree(ml_tree) +\n  geom_tiplab(size=3) +\n  ggtitle(\"ML (GTR+Γ+I) tree of Pst s.l.\") +\n  theme_tree2()\nprint(p_tree)\n\n\n\n\n\n\n\n# 7. Add alignment facets -----------------------------------------------------\nmsa1 &lt;- tidy_msa(align_file, 170, 220)\nmsa2 &lt;- tidy_msa(align_file, 270, 320)\n\np_align &lt;- ggtree(rescale_tree(ml_tree, \"dN\"), branch.length=0) +\n  geom_tiplab(size=2.2, offset=0.001) +\n  theme_tree2() +\n  geom_facet(\n    geom    = geom_msa,\n    data    = msa1,\n    panel   = \"170–220 bp\",\n    font    = \"helvetical\",\n    color   = \"Chemistry_NT\"\n  ) +\n  geom_facet(\n    geom    = ggmsa:::geom_logo,\n    data    = msa1,\n    panel   = \"170–220 bp\",\n    mapping = aes(x=x, logo=char),\n    stat    = \"logo\",\n    color   = \"Chemistry_NT\",\n    adaptive= FALSE\n  ) +\n  geom_facet(\n    geom    = geom_msa,\n    data    = msa2,\n    panel   = \"270–320 bp\",\n    font    = \"helvetical\",\n    color   = \"Chemistry_NT\"\n  ) +\n  geom_facet(\n    geom    = ggmsa:::geom_logo,\n    data    = msa2,\n    panel   = \"270–320 bp\",\n    mapping = aes(x=x, logo=char),\n    stat    = \"logo\",\n    color   = \"Chemistry_NT\",\n    adaptive= FALSE\n  ) +\n  xlim_tree(2) +\n  theme(strip.text.x = element_text(size=14, face=\"bold\"))\n\nprint(p_align)\n\n\n\n\n\n\n\n# 8. Save the alignment+tree figure ------------------------------------------\nggsave(\n  filename = \"output/Pst_sl_ggtree.ggmsa.pdf\",\n  plot     = p_align,\n  width    = 10,\n  height   = 6\n)"
  },
  {
    "objectID": "3_rust.html#seasonal-dynamics-of-cereal-rust-species-in-bc-during-2015-2018",
    "href": "3_rust.html#seasonal-dynamics-of-cereal-rust-species-in-bc-during-2015-2018",
    "title": "Validation & Visualization",
    "section": "Seasonal Dynamics of Cereal rust species in BC during 2015-2018",
    "text": "Seasonal Dynamics of Cereal rust species in BC during 2015-2018\n\n\n\n\n\n\nR Block\n\n\n\n\n# 1. === Define your target rust species & nicer labels ===\ntarget &lt;- tribble(\n  ~code,                                   ~name,\n  \"Puccinia_coronata.VARavenaeFSPavenae\",  \"Puccinia coronata var. avenae f.sp. avenae\",\n  \"Puccinia_graminis.CladeII\",            \"Puccinia graminis CladeII\",\n  \"Puccinia_graminis.CladeIII\",           \"Puccinia graminis CladeIII\",\n  \"Puccinia_striiformis\",                 \"Puccinia striiformis\",\n  \"Puccinia_recondita.CladeIV\",           \"Puccinia recondita CladeIV\",\n  \"Puccinia_recondita.CladeVI\",           \"Puccinia recondita CladeVI\",\n  \"Puccinia_hordei.CladeI\",               \"Puccinia hordei CladeI\"\n)\n\n# 2. === Subset to BC & drop empty taxa/samples ===\n\nps &lt;- readRDS(\"output/phyloseq_rust_aodp.rds\")\n\nps_bc &lt;- ps %&gt;%\n  subset_samples(Province==\"BC\") %&gt;%\n  prune_taxa(taxa_sums(.)&gt;0, .) %&gt;%\n  prune_samples(sample_sums(.)&gt;0, .)\n\n# 3. === Build species‐by‐sample rel‐abundance table ===\nsp_ra &lt;- ps_bc %&gt;%\n  # extract tables\n  otu_table(., taxa_are_rows=TRUE) %&gt;% as.matrix() %&gt;% \n  as.data.frame() %&gt;% \n  rownames_to_column(\"ASV\") %&gt;%\n  left_join(\n    as.data.frame(tax_table(ps_bc)) %&gt;% rownames_to_column(\"ASV\") %&gt;% select(ASV, species),\n    by=\"ASV\"\n  ) %&gt;%\n  select(-ASV) %&gt;%\n  group_by(species) %&gt;%\n  summarise(across(everything(), sum), .groups=\"drop\") %&gt;%\n  column_to_rownames(\"species\") %&gt;%\n  t() %&gt;%                                   # now samples × species\n  sweep(1, rowSums(.), \"/\") %&gt;%             # rel‐abundance\n  as.data.frame() %&gt;%\n  rownames_to_column(\"SampleID\")\n\n# 4. === Pivot longer & join metadata ===\ndf_long &lt;- sp_ra %&gt;%\n  pivot_longer(\n    cols = any_of(target$code),\n    names_to  = \"SpeciesCode\",\n    values_to = \"RelAbund\"\n  ) %&gt;%\n  left_join(\n    ps_bc %&gt;% sample_data() %&gt;% \n      as.matrix() %&gt;%\n      as.data.frame() %&gt;% \n      rownames_to_column(\"SampleID\") %&gt;%\n      select(SampleID, Year, Sample_week, Month, SiteID),\n    by=\"SampleID\"\n  ) %&gt;%\n  mutate(\n    SpeciesName = target$name[match(SpeciesCode, target$code)],\n    SiteID      = factor(SiteID, levels=c(\"AG\",\"AR\",\"DC\"))\n  )\n\n\n# 5. === Compute monthly means & SE (%) ===\ndf_monthly &lt;- df_long %&gt;%\n  group_by(SpeciesCode, SpeciesName, Year, SiteID, Month) %&gt;%\n  summarise(\n    Mean   = mean(RelAbund, na.rm=TRUE)*100,\n    SE     = sd(RelAbund, na.rm=TRUE)/sqrt(n())*100,\n    .groups=\"drop\"\n  )\n\n# 6. === Function to make & save one plot ===\nmake_plot &lt;- function(code, name, label) {\n  dat &lt;- filter(df_monthly, SpeciesCode==code)\n  p &lt;- ggplot(dat, aes(x=Month, y=Mean, group=Year)) +\n    geom_line() +\n    geom_point() +\n    geom_errorbar(aes(ymin=Mean-SE, ymax=Mean+SE), width=0.2) +\n    facet_grid(SiteID~Year, scales=\"free_y\") +\n    labs(\n      subtitle = paste0(label, \") \", name),\n      x = \"Month\", y=\"Mean rel. abundance (%)\"\n    ) +\n    theme_minimal(base_size=12) +\n    theme(\n      strip.background = element_rect(fill=\"grey80\", color=\"black\"),\n      axis.text.x = element_text(angle=45, hjust=1),\n      plot.subtitle = element_text(face=\"bold\")\n    )\n  \n  # save\n  ggsave(\n    file.path(\"output\", sprintf(\"BC_%s_monthly.pdf\", code)),\n    plot = p, width=6, height=4\n  )\n  p\n}\n\n# 7. === Loop once to build all plots ===\n# What are the cereal rust species to be plotted?\npresent &lt;- levels(factor(df_monthly$SpeciesCode))\npresent &lt;- target[target$code %in% present, ]\nprint(present)\n\n# A tibble: 6 × 2\n  code                                 name                                     \n  &lt;chr&gt;                                &lt;chr&gt;                                    \n1 Puccinia_coronata.VARavenaeFSPavenae Puccinia coronata var. avenae f.sp. aven…\n2 Puccinia_graminis.CladeII            Puccinia graminis CladeII                \n3 Puccinia_graminis.CladeIII           Puccinia graminis CladeIII               \n4 Puccinia_striiformis                 Puccinia striiformis                     \n5 Puccinia_recondita.CladeVI           Puccinia recondita CladeVI               \n6 Puccinia_hordei.CladeI               Puccinia hordei CladeI                   \n\nlabels &lt;- toupper(letters[1:nrow(present)])\nplots &lt;- pmap(\n  list(present$code, present$name, labels),\n  make_plot\n) %&gt;% set_names(present$code)\n\n# 8. === Combine a subset as a grid for one figure ===\ngrid &lt;- plot_grid(\n  plotlist = plots[present$code], \n  ncol=3, nrow=3\n)\n\nggsave(\"output/BC_all_monthly.pdf\", grid, width=16, height=12)\n\nprint(plots$Puccinia_coronata.VARavenaeFSPavenae)\n\n\n\n\n\n\n\nprint(plots$Puccinia_striiformis)"
  },
  {
    "objectID": "1_data.html",
    "href": "1_data.html",
    "title": "Data used for this workshop",
    "section": "",
    "text": "Identification of Rust Fungal Species through Metabarcoding and AODP"
  },
  {
    "objectID": "1_data.html#background",
    "href": "1_data.html#background",
    "title": "Data used for this workshop",
    "section": "Background",
    "text": "Background\nAir samples were collected by Burkard Cyclone spore samplers from three pilot sites in British Columbia during 2015-2018 and five sites in Alberta in 2018, western Canada. Sampling sites at Agassiz and Armstrong are 230 km apart, 803 km between those at Agassiz and Dawson Creek and 645 km between those at Armstrong and Dawson Creek. Airborne spores were systematically collected each week, spanning from April to November, in British Columbia over four consecutive years, starting in the Spring of 2015 and concluding in the Fall of 2018.The ITS2 region was amplified using a rust-enhanced primer pair Rust2inv (5′-GAT GAA GAA CAC AGT GAA A-3′) and ITS4var_H (5′- TCC TCY GCT TAT TGA TAT GC-3′). The re-amplified PCR products were sent to the Génome Québec Innovation Centre (Montréal, QC, Canada) for paired end PE300 sequencing using the Illumina MiSeq platform.\nThe raw sequencing data were processed using the DADA2 Divisive Amplicon Denoising pipeline wrapped in the Quantitative Insights Into Microbial Ecology version 2 (Qiime 2) bioinformatics suite (Estaki et al. 2020), which allowed us to generate an Amplicon Sequence Variant (ASV) table. The ITS2 region of the representative sequences of the ASVs were extracted by ITSx (Bengtsson-Palme et al. 2013).\nMore information about the dataset can be found in (Chen et al. 2024)\n\n\n\nFigure 1. Geographic location and environmental conditions at the spore sampling sites."
  },
  {
    "objectID": "1_data.html#prepare-data-for-aodp",
    "href": "1_data.html#prepare-data-for-aodp",
    "title": "Data used for this workshop",
    "section": "Prepare data for AODP",
    "text": "Prepare data for AODP\n\nImport QIIME2 outputs\n\n\n\n\n\n\nR Block\n\n\n\n\n# load libraries\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(Biostrings)\nlibrary(phyloseq)\n\n\n# import asv file\nasv &lt;- read.table(\"qiime2.outputs_and_metadata/feature-table.tsv\", sep = \"\\t\", header = TRUE, row.names = 1)\ndim(asv) \n\n[1] 11656   271\n\nhead(names(asv))\n\n[1] \"Ag.2015.30\" \"Ag.2015.35\" \"Ag.2015.29\" \"Ag.2015.32\" \"Ag.2015.31\"\n[6] \"Ag.2015.38\"\n\n\n\n# import q2 taxonomy \ntax &lt;- read.table (\"qiime2.outputs_and_metadata/taxonomy.tsv\", sep = \"\\t\", header = TRUE, row.names = 1) %&gt;%\n  mutate(Taxon=gsub(\"[dkpcofgs]__\", \"\", Taxon)) %&gt;%\n  separate(\n    col    = Taxon,\n    into   = c(\"kingdom\",\"phylum\",\"class\",\"order\",\"family\",\"genus\",\"species\"),\n    sep    = \";\",\n    fill   = \"right\",    # pad missing pieces on the right with NA\n    remove = TRUE       # remove the original Taxon column \n  ) %&gt;%\n  select(-Confidence) %&gt;%\n  # replace \"unidentified to NA\n  mutate(across(\n    kingdom:species,\n    ~ ifelse(is.na(.) | . == \"unidentified\", NA, .),  # (optional) re-NA any true missing\n    .names = \"{.col}\"\n  )) %&gt;%\n  # fix taxonomy to include LCA\n  # now build each rank via coalesce() on the *original* columns\n  mutate(\n    class   = coalesce(class,   paste0(phylum,  \"_sp\")),\n    order   = coalesce(order,   paste0(class,   \"_sp\")),\n    family  = coalesce(family,  paste0(order,   \"_sp\")),\n    genus   = coalesce(genus,   paste0(family,  \"_sp\")),\n    species = coalesce(species, paste0(genus,   \"_sp\"))\n  ) %&gt;%\n  mutate(across(\n    kingdom:species,\n    # collapse any run of \"_sp\" at the end into a single \"_sp\"\n    function(x) {\n      # collapse any run of \"_sp\" at the end into a single \"_sp\"\n      sub(\"(_sp)+$\", \"_sp\", x)\n    }\n  ))\n\ndim(tax) # 11645     7\n\n[1] 11645     7\n\nhead(tax)\n\n                                 kingdom        phylum           class\n0001e9647af93de910d25e693156fb6a   Fungi    Ascomycota   Ascomycota_sp\n000209c8100a89e11ab93ce320763e6f   Fungi Basidiomycota Tremellomycetes\n000c1ea6e5b1e40002e820be9528938a   Fungi    Ascomycota Dothideomycetes\n000cef60631bedcaee35214ebfb5d855   Fungi    Ascomycota Dothideomycetes\n0011c1d5dffe970a2bc0c83af2fa034a   Fungi Basidiomycota  Agaricomycetes\n00158b1404902009ce605322d92da764   Fungi Basidiomycota Pucciniomycetes\n                                         order            family         genus\n0001e9647af93de910d25e693156fb6a Ascomycota_sp     Ascomycota_sp Ascomycota_sp\n000209c8100a89e11ab93ce320763e6f   Tremellales       Bulleraceae   Genolevuria\n000c1ea6e5b1e40002e820be9528938a  Pleosporales     Periconiaceae     Periconia\n000cef60631bedcaee35214ebfb5d855   Venturiales Sympoventuriaceae    Ochroconis\n0011c1d5dffe970a2bc0c83af2fa034a   Polyporales       Meruliaceae       Phlebia\n00158b1404902009ce605322d92da764   Pucciniales   Coleosporiaceae    Chrysomyxa\n                                            species\n0001e9647af93de910d25e693156fb6a      Ascomycota_sp\n000209c8100a89e11ab93ce320763e6f     Genolevuria_sp\n000c1ea6e5b1e40002e820be9528938a       Periconia_sp\n000cef60631bedcaee35214ebfb5d855      Ochroconis_sp\n0011c1d5dffe970a2bc0c83af2fa034a Phlebia_margaritae\n00158b1404902009ce605322d92da764      Chrysomyxa_sp\n\n\n\n# load phylogenetic tree\ntree_file &lt;- \"qiime2.outputs_and_metadata/tree_rooted.nwk\"\ntree &lt;- ape::read.tree(tree_file)\ntree # 15668 tips\n\n\nPhylogenetic tree with 11656 tips and 11591 internal nodes.\n\nTip labels:\n  4e846c00c92f48052aef3c802497d67b, 553ba2eb7db09b15033a6587cbe0f82c, 75f9cdcc1402f6e1322ddbe426536d75, 079d917301099c1b611b88f27d6a6269, ab2e014068378c5694ea24ad313e3147, 5811498736402e36b957197cd33dd3b7, ...\nNode labels:\n  0.307, 0.996, 0.910, 1.000, 0.565, 0.863, ...\n\nRooted; includes branch length(s).\n\n\n\n# load ASV representative sequences\nrep_file &lt;- \"qiime2.outputs_and_metadata/rep-seqs_ITS2.fasta\"\nrep &lt;- Biostrings::readDNAStringSet(rep_file)\nrep # 15395\n\nDNAStringSet object of length 15395:\n        width seq                                           names               \n    [1]   167 CACCAATCAAGCTCTGCTTGG...AAAACACCAATACATCAAAGG 0001e9647af93de91...\n    [2]   180 AAAATCAATCCCCACGGGTTT...CCTCGGGCAACTACTTTTTGC 000209c8100a89e11...\n    [3]   158 ACACCTTCAAGCCTAGCTTGG...CCAGCAAGCTACTTTTATGAC 000c1ea6e5b1e4000...\n    [4]   177 CACACCCCAAGCTGTGCTTGA...TGAACAACTTCTAAACAAAGT 000cef60631bedcae...\n    [5]   195 AATCCTCAACCCTCCCTCCCT...TTCGGGACAGCTTTTTCGAAT 0011c1d5dffe970a2...\n    ...   ... ...\n[15391]   204 AATTCTCAACCTCACCAGTTT...CAAGGACAATACCTTGACAAT ffe3f8e4e92f49518...\n[15392]   150 CACCACTCAAGCCTCGCTTGG...AAAACAACCCCATTTCTAAGG ffe8f1b7a999794ef...\n[15393]   157 TCAACCATCAAGCTCTGCTTG...CCAAAACCCATCACCTCAAGG ffe961af85fa9b3f7...\n[15394]   200 GAACACATCACCTCCCTTAGG...CGGGGACCATCTTTTTACGCT fff2e443e70df58fb...\n[15395]   215 AACCCTCTCATTAAACAATTT...AAACCCATACATTTTATTTTT fff392eb19c184f98...\n\n# Filter for sequences with width ≥ 100 bp\nrep_filtered &lt;- rep[width(rep) &gt;= 100]\n\n# Check how many are retained\nlength(rep_filtered) # 15291\n\n[1] 15291\n\nsource(\"./scripts/functions.R\")\n\ncolor_dna(rep_filtered, n = 5)\n\n[1] 167 bp  0001e9647af93de910d25e693156fb6a  CACCAATCAAGCTCTGCTTGGTATTGGGCCCTCGTCCCCCCCCTCGCGGGGGGGTCGTGCCCCGAAACATTCGGCGAAGTCACATCGGCTTTGGGCGTAGTAGAATTTCCATAACGTTCACGAGTCCGGCGAGGCCTTCTGCCGCAAAAACACCAATACATCAAAGG\n[2] 180 bp  000209c8100a89e11ab93ce320763e6f  AAAATCAATCCCCACGGGTTTCTGACCCGGCGGTGGACTTGGAGTTGGGCGTCTGCCGGTCACACGGCTCGCCTCAAAGACCTTAGTGGGAACATCGGCCTATGGCTTGACGTAATAAGTTTCGTCTCGCACGGTCGGTGACGCCTGCTCACAACCAGCCCTCGGGCAACTACTTTTTGC\n[3] 158 bp  000c1ea6e5b1e40002e820be9528938a  ACACCTTCAAGCCTAGCTTGGTGTTGGGCGTCTGTCCCGCACTCGTTGCGCGGACTCGCCTCAAAGTCATTGGCGGCGGTCGTGCCGGCTCCTCGCGCAGCACATTTGCGCTTCTCGGAGGCCCGGCGGATCAGCATCCAGCAAGCTACTTTTATGAC\n[4] 177 bp  000cef60631bedcaee35214ebfb5d855  CACACCCCAAGCTGTGCTTGATGTTGGACGCTGTCTGTGAAAGGACAGGTCTGGAACGCGTGGGCGCCGCCGCCGGACCACGAGCGTAGCAAGACGCAAGTCATTCGCTGTGTGGAATCTGGTGGGTGGTGGCCGTTGTGGCGGGTAAGACCGACATGAACAACTTCTAAACAAAGT\n[5] 195 bp  0011c1d5dffe970a2bc0c83af2fa034a  AATCCTCAACCCTCCCTCCCTTGTGGACGGGATGGGCTTGGAATTGGAGGTCTTGCCGTCCGTAGTGGTCGGCTCCTCTCAAATGCATTAGCTCGGTTCTTAGCGGATCGGCTCCCGGCGTGATAATTGTCTACGTCGCGACCGTGAAGCGTCTGGCCGGCTTCCAATCGTCCCTTCGGGACAGCTTTTTCGAAT\n\n\n\n\n\n\nImport metadata\n\n\n\n\n\n\nR Block\n\n\n\n\n# load metadata\nmeta &lt;- openxlsx::read.xlsx(\"qiime2.outputs_and_metadata/meta.xlsx\", rowNames = TRUE)\nhead(meta[, 1:5])\n\n           Year SiteID       Date Month Sample_week\nAg.2015.30 2015     AG 2015-07-24     7          30\nAg.2015.35 2015     AG 2015-08-28     8          35\nAg.2015.29 2015     AG 2015-07-17     7          29\nAg.2015.32 2015     AG 2015-08-07     8          32\nAg.2015.31 2015     AG 2015-07-31     7          31\nAg.2015.38 2015     AG 2015-09-18     9          38\n\ndim(meta)\n\n[1] 271  12"
  },
  {
    "objectID": "1_data.html#create-phyloseq-object",
    "href": "1_data.html#create-phyloseq-object",
    "title": "Data used for this workshop",
    "section": "Create phyloseq object",
    "text": "Create phyloseq object\n\n\n\n\n\n\nR Block\n\n\n\n\n# create phyloseq object\nps_ASV &lt;- otu_table(asv, taxa_are_rows = TRUE)\nps_TAX &lt;- tax_table(as.matrix(tax))\nps_META &lt;- sample_data(meta)\nps &lt;- phyloseq(ps_ASV, ps_TAX) %&gt;%\n         merge_phyloseq(., ps_META) %&gt;%\n         merge_phyloseq(., tree) %&gt;%\n         merge_phyloseq(., rep)\nps\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 11645 taxa and 271 samples ]\nsample_data() Sample Data:       [ 271 samples by 12 sample variables ]\ntax_table()   Taxonomy Table:    [ 11645 taxa by 7 taxonomic ranks ]\nphy_tree()    Phylogenetic Tree: [ 11645 tips and 11580 internal nodes ]\nrefseq()      DNAStringSet:      [ 11645 reference sequences ]\n\nsaveRDS(ps, \"output/phyloseq_all.rds\")"
  },
  {
    "objectID": "1_data.html#subset-the-rust-fungal-community",
    "href": "1_data.html#subset-the-rust-fungal-community",
    "title": "Data used for this workshop",
    "section": "Subset the rust fungal community",
    "text": "Subset the rust fungal community\n\n\n\n\n\n\nR Block\n\n\n\n\nps &lt;- readRDS(\"output/phyloseq_all.rds\")\n\n# Subset rust fungal community only\nps.rust &lt;- subset_taxa(ps, order == \"Pucciniales\") %&gt;%\n              # remove ASVs with zero reads\n              prune_taxa(taxa_sums(.) &gt; 0, . ) %&gt;%\n              # remove samples with zero reads\n              prune_samples(sample_sums(.) &gt; 0, .)\n\nps.rust\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 768 taxa and 242 samples ]\nsample_data() Sample Data:       [ 242 samples by 12 sample variables ]\ntax_table()   Taxonomy Table:    [ 768 taxa by 7 taxonomic ranks ]\nphy_tree()    Phylogenetic Tree: [ 768 tips and 767 internal nodes ]\nrefseq()      DNAStringSet:      [ 768 reference sequences ]\n\nhead(tax_table(ps.rust)[tax_table(ps.rust)[, \"genus\"]==\"Puccinia\", ])\n\nTaxonomy Table:     [6 taxa by 7 taxonomic ranks]:\n                                 kingdom phylum          class            \n4ab5d797219ea5306ebce5f0333fe2be \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n4d483466236a2e113140e36e7de6499c \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n640c996f4e4765310497bd1244973f82 \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\nb006dbb25ca81c89d73fe86032f9c03a \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\nce65fe6eeeb329fafee9e548f1723502 \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n4fe30f4670ab9c998662afe56de8aa3b \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n                                 order         family         genus     \n4ab5d797219ea5306ebce5f0333fe2be \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n4d483466236a2e113140e36e7de6499c \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n640c996f4e4765310497bd1244973f82 \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\nb006dbb25ca81c89d73fe86032f9c03a \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\nce65fe6eeeb329fafee9e548f1723502 \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n4fe30f4670ab9c998662afe56de8aa3b \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n                                 species                \n4ab5d797219ea5306ebce5f0333fe2be \"Puccinia_sp\"          \n4d483466236a2e113140e36e7de6499c \"Puccinia_sp\"          \n640c996f4e4765310497bd1244973f82 \"Puccinia_tanaceti\"    \nb006dbb25ca81c89d73fe86032f9c03a \"Puccinia_tanaceti\"    \nce65fe6eeeb329fafee9e548f1723502 \"Puccinia_tanaceti\"    \n4fe30f4670ab9c998662afe56de8aa3b \"Puccinia_punctiformis\"\n\nsaveRDS(ps.rust, \"output/phyloseq_rust.rds\")"
  },
  {
    "objectID": "1_data.html#export-representative-sequences-of-rust-fungi",
    "href": "1_data.html#export-representative-sequences-of-rust-fungi",
    "title": "Data used for this workshop",
    "section": "Export representative sequences of rust fungi",
    "text": "Export representative sequences of rust fungi\n\n\n\n\n\n\nR Block\n\n\n\n\n# keep sequences longer than 100 bp\nrep.rust &lt;- refseq(ps.rust) %&gt;%\n  { .[width(.) &gt;= 100] }\n\n# Write Pucciniales representative sequences  \nBiostrings::writeXStringSet(rep.rust, \"output/Pucciniales_asv.fasta\", \n                            append=FALSE, width=20001,\n                            compress=FALSE, compression_level=NA, format=\"fasta\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "This workshop is prepared for the joint 17th International Cereal Rusts and Powdery Mildews Conference (ICRPMC2025), the Canadian Phytopathological Society (CPS) Annual Meeting, and the Bourlag Global Rust Initiative (BGRI)Technical Workshop scheduled for June 15-20, 2025 in Vancouver, British Columbia at the at UBC Vancouver campus."
  },
  {
    "objectID": "index.html#workshop-organizing-committee",
    "href": "index.html#workshop-organizing-committee",
    "title": "Introduction",
    "section": "Workshop organizing committee",
    "text": "Workshop organizing committee\n\nLead workshop organiser, preparation of workshop material and website\n\nWen Chen - wen.chen@agr.gc.ca, wchen@uottawa.ca\n\n\n\nInstructors\n\nSamuel Holden sholden1@ualberta.ca\nDavid Kim david.kim2@agr.gc.ca\nSean Formby sean.formby@gmail.com; sean.formby@gmail.com\n\n\n\nScientific advisors\n\nGuus Bakkeren guus.bakkeren@AGR.GC.CA;\nSean Li sean.li@inspection.gc.ca sean.li@inspection.gc.ca;\nGurcharn Brar gurcharn@ualberta.ca"
  },
  {
    "objectID": "index.html#diagnostic-metagenomics-in-plant-pathology",
    "href": "index.html#diagnostic-metagenomics-in-plant-pathology",
    "title": "Introduction",
    "section": "Diagnostic Metagenomics in Plant Pathology",
    "text": "Diagnostic Metagenomics in Plant Pathology\nWorking with any plant-associated microbe comes with the inherent challenge that no environment is sterile, and a plant’s metabiome is teeming with life. When collecting field samples outside of the laboratory, the issue is compounded further. In this era of big data and easy access to high throughput sequencing, it is increasingly common for scientists to work with large sequence datasets which must first be evaluated for quality and potential contaminating reads. Sequence data files from environmental samples often contain genetic material from organisms not targeted by the experimental design. Understanding how to identify species from NGS sequencing data, or from targeted sequencing such as ITS spacers while properly accounting for common sources of error and bias is a valuable skill which can be of use to researchers who are beginning a new metagenomic project, or who are mid-way through analysing large and targeted datasets\nThis workshop provides hands-on trainings on in silico approaches for identifying and classifying samples from sequencing data, drawing on experience with rust fungus-infected cereal samples collected from fields. However, the concepts we intend to explore in the workshop are broadly applicable so they can be tailored to specific species of interest."
  },
  {
    "objectID": "index.html#introduction-to-aodp",
    "href": "index.html#introduction-to-aodp",
    "title": "Introduction",
    "section": "Introduction to AODP",
    "text": "Introduction to AODP\nThe Automated Oligonucleotide Design Pipeline (AODP) (Chen, Radford, and Hambleton 2021) is an open-source software designed to identify “signature oligonucleotides” from a reference sequence dataset . These are defined as subsequences that exclusively and perfectly match a specific group of sequences. The software then uses signature oligonucleotides to either confirm or rule out matching sequences in a query dataset, followed by performing modified Needleman–Wunsch algorithm for global alignment (Manuel Zahariev et al. 2018). AODP was specifically developed to enhance pathogen detection accuracy in short metabarcodes by identifying mutations within highly conserved marker regions (M. Zahariev et al. 2009). This capability allows for the precise discrimination of short metabarcodes (e.g., ITS sequence) down to the species level or below, especially relevant with the f.spp of rusts.\nStep-by-step tutorial can also be found in (Holden et al. 2025)"
  },
  {
    "objectID": "index.html#special-notification",
    "href": "index.html#special-notification",
    "title": "Introduction",
    "section": "Special Notification",
    "text": "Special Notification\nThis workshop is intended for participants already familiar with command-line tools and Linux operating systems. It is not suitable for beginners seeking basic Linux training. Participants should bring their own laptops equipped with a Linux virtual machine installed via VirtualBox or with access to a Linux-based HPC server. Instructors will provide detailed instructions to all registrants on setting up the necessary working environment, which must be completed prior to attending the workshop.\nYOU MUST COMPLETE THE ENVIRONMENT SETUP BEFORE ATTENDING THE WORKSHOP."
  },
  {
    "objectID": "0_setup.html",
    "href": "0_setup.html",
    "title": "Required Components",
    "section": "",
    "text": "Identification of Rust Fungal Species through Metabarcoding and AODP\nYOU MUST COMPLETE THE ENVIRONMENT SETUP BEFORE ATTENDING THE WORKSHOP."
  },
  {
    "objectID": "0_setup.html#operating-system",
    "href": "0_setup.html#operating-system",
    "title": "Required Components",
    "section": "💻 Operating System",
    "text": "💻 Operating System\nYou should use a laptop with Linux operational system for this workshop.\nWindows users should install a Linux virtual machine via VirtualBox or use WSL2."
  },
  {
    "objectID": "0_setup.html#conda-or-mamba-setup",
    "href": "0_setup.html#conda-or-mamba-setup",
    "title": "Required Components",
    "section": "🐍 Conda or Mamba Setup",
    "text": "🐍 Conda or Mamba Setup\nWe will use Conda (or Mamba)1 to manage software environments.\n\nRecommended: Mambaforge\nAlternative: Miniconda\n\n\n✅ Test your installation:\n\n\n\n\n\n\nBASH Block\n\n\n\n\nwhich conda\nconda --version\n\nwhich mamba\nmamba --version\n\n# If these return paths like /opt/conda/bin/conda or /Users/yourname/mambaforge/bin/mamba, you're good to go.\n\n# To set mamba as the default (for its performance)\n# add this to your ~/.bashrc\n# export PATH=\"/Users/chenw/mambaforge/bin:$PATH\"\n# source ~/.bashrc"
  },
  {
    "objectID": "0_setup.html#git-installation",
    "href": "0_setup.html#git-installation",
    "title": "Required Components",
    "section": "🔧 Git Installation",
    "text": "🔧 Git Installation\nGit is a version control system used to track changes and collaborate on data projects, including scripts, data, figures, and documents.\n📌 Install Git for your operating system.\n\n\n\n\n\n\nBASH Block\n\n\n\n\n\n# 1. clone the github repository\ngit clone https://github.com/WenChenAAFC/rust_fungi_identification_using_metabarcoding_and_AODP.git\n\n# 2. switch to the working directory\ncd rust_fungi_identification_using_metabarcoding_and_AODP\n\n# 3. get the path of the working directory\nwkdir=`pwd` # NO space\necho $wkdir\nls -lah\n\n# 4. Examine the folder structure;\ntree -d # only show directories\ntree -d -n # -n disables color output"
  },
  {
    "objectID": "0_setup.html#installing-aodp-with-dependencies-and-other-tools",
    "href": "0_setup.html#installing-aodp-with-dependencies-and-other-tools",
    "title": "Required Components",
    "section": "⚙️ Installing AODP with dependencies and other tools",
    "text": "⚙️ Installing AODP with dependencies and other tools\n\n\n\n\n\n\nBASH Block\n\n\n\n\n\n# Check your working directory, should be PATH_to_rust_fungi_identification_using_metabarcoding_and_AODP\necho $wkdir\ncd $wkdir\n\n# 1. (Optional) Reinstall mamba if it’s misbehaving\n# conda activate base\n# conda remove mamba --yes\n# conda clean --all --yes\n# conda install -c conda-forge mamba --yes\n\n# 2. (Optional) Remove any old training env, for example:\n# mamba env remove -n aodp-training --yes\n\n# 3. Create a fresh aodp-training env with the core dependencies\nmamba create -n aodp-training -c conda-forge -c bioconda \\\n  gcc_linux-64=10.4.0 \\\n  gxx_linux-64=10.4.0 \\\n  make \\\n  perl \\\n  perl-bioperl \\\n  blast \\\n  --yes\n\n# 4. (Optional) Add ITSx\nmamba install -n aodp-training -c conda-forge -c bioconda itsx --yes\nwhich itsx\n\n# 5. Activate and verify\nconda activate aodp-training\n\n# 5a. Check Perl\nwhich perl\nperl -MBio::Seq -e 'print \"Bioperl is working\\n\";' \\\n  || { \n       export PATH=\"$CONDA_PREFIX/bin:$PATH\"; \n       hash -r; \n       which perl; \n       perl -MBio::Seq -e 'print \"Bioperl is working\\n\";' \n     }\nconda list perl-bioperl\n\n# 6. Build & install AODP\ncd aodp_v2.0_release\ntar xvzf aodp-2.5.0.1.tar.gz\ncd aodp-2.5.0.1\n\nexport CXXFLAGS=\"-std=c++11\"\n./configure \\\n  BIN_TARGET_DIR=\"$PWD\" \\\n  MAN_TARGET_DIR=\"$PWD/man\"\n\nmake clean && make\nmake install\n\n# Temporally add aodp to PATH\nexport PATH=\"$PATH:$aodpDIR\";\n\n# to permanently add aodp to PATH,\n# add above line to your ~/.bashrc \n# e.g. add \"export PATH=\"$PATH:/gpfs/fs7/aafc/labs/chenw_lab/workspace/chenw/RustIDing_using_metabarcoding_and_AODP/aodp_v2.0_release/aodp-2.5.0.1\"\n# source ~/.bashrc\n\n# Test installation\nwhich aodp\naodp --help\n\n#------------------------------\n# 7. (Optonal) check other software installed, \n#------------------------------\n# [ITSx is an open source software utility to extract the highly variable ITS1 and ITS2 subregions from ITS sequences, which is commonly used as a molecular barcode for e.g. fungi.](https://microbiology.se/software/itsx/)\nwhich ITSx\nITSx --help\n\n# To deactivate environment\nconda deactivate"
  },
  {
    "objectID": "0_setup.html#review-other-data-folders-and-accessory-scripts",
    "href": "0_setup.html#review-other-data-folders-and-accessory-scripts",
    "title": "Required Components",
    "section": "🧬 Review other data folders and accessory scripts",
    "text": "🧬 Review other data folders and accessory scripts\n\n\n\n\n\n\nBASH Block\n\n\n\n\necho $wkdir\ncd $wkdir\n\n# 1. QIIME2 outputs\nls -lah qiime2.outputs_and_metadata\n\n# 2. The Rust ITS2 Database \nls -lah refDBs \n# find CR-ITS2-refDB -this is a high-quality, curated ITS2 reference database for cereal rust fungal species or species complexes, compiled by Dr. Sarah Hambleton [@RN3722]\n\n# 3. Additional R functions\nls -lah scripts  \n# find function.R — this script contain an R function that wraps DNA sequences in HTML spans with nucleotide-specific colors, and then prints them using the htmltools::HTML() function so Quarto renders it with full color in HTML output."
  },
  {
    "objectID": "0_setup.html#r-and-rstudio-setup",
    "href": "0_setup.html#r-and-rstudio-setup",
    "title": "Required Components",
    "section": "📊 R and RStudio Setup",
    "text": "📊 R and RStudio Setup\n\nInstall R and RStudio\n\n\nR\nRStudio Desktop\n\n\nInstalling the required R packages\n\n\n\n\n\n\n\nR Block\n\n\n\n\n# 1. CRAN packages\nrequired_cran &lt;- c(\"openxlsx\", # Read, write, and edit Microsoft Excel file\n                   \"dplyr\", # data manipulation: filter, select, mutate, summarize, join, etc.\n                   \"tidyr\", # turning “messy” data into tidy data frames.\n                   \"stringr\", # simple wrappers for string operations (pattern matching, replacement, etc.).\n                   \"tibble\",  # Modern reimagining of data.frame: better printing, stricter checks, etc\n                   \"splitstackshape\", # Stack and reshape datasets after splitting concatenated values\n                   \"purrr\", # Functional-programming tools for working with lists/vectors.\n                   \"ggplot2\", # creating graphics, based on “The Grammar of Graphics.\n                   \"cowplot\", # Extensions to ggplot2 for arranging multiple plots and adding annotations.\n                   \"ape\", # Analyses of phylogenetics and evolution: tree manipulation, plotting, etc\n                   \"phangorn\" # Phylogenetic inference and evolutionary analyses\n                   )\nif (!requireNamespace(required_cran, quietly = TRUE)) {\n  install.packages(required_cran, repos = \"http://cran.rstudio.com\", dependencies = TRUE)\n}\n\n# 2. Bioconda packages:\nif (!requireNamespace(\"BiocManager\", quietly = TRUE)) {\n  install.packages(\"BiocManager\")\n}\n\nrequired_bioc &lt;- c(\"phyloseq\", # Import, store, analyze and graph microbiome census data (OTUs, taxonomy, phylogeny, sample data).\n                    \"Biostrings\", # Efficient containers and utilities for biological sequences (DNA, RNA, AA strings).\n                   \"ggtree\", # Grammar-of-graphics plotting and annotation of phylogenetic trees.\n                   \"msa\", # Interface to multiple sequence alignment algorithms (ClustalW/Omega, MUSCLE) in R.\n                   \"ggmsa\", # Alignment visualization in a ggplot2-style (sequence and tree insets).\n                   \"treeio\" # Import, export, and manipulate richly annotated phylogenetic tree formats (e.g. Newick, Nexus).\n                   )\nif (!requireNamespace(required_bioc, quietly = TRUE)) {\n  BiocManager::install(required_bioc)\n}\n\n# 3. Alternatively, # 3. Install ggmsa from GitHub via devtools\nif (!requireNamespace(\"devtools\", quietly = TRUE)) {\n  install.packages(\"devtools\")\n}\ndevtools::install_github(\"YuLab-SMU/ggmsa\")\n\nUsing GitHub PAT from the git credential store.\n\n\nSkipping install of 'ggmsa' from a github remote, the SHA1 (b90d4b9f) has not changed since last install.\n  Use `force = TRUE` to force installation\n\n# Verify installation\npackageVersion(\"ggmsa\") \n\n[1] '1.13.1'\n\n# 4. Check your R session\nsessionInfo() # This command will tell you information about your current R session\n\nR version 4.4.3 (2025-02-28)\nPlatform: x86_64-apple-darwin20\nRunning under: macOS Sequoia 15.5\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/Toronto\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n  [1] ade4_1.7-23             tidyselect_1.2.1        dplyr_1.1.4            \n  [4] farver_2.1.2            Biostrings_2.74.1       fastmap_1.2.0          \n  [7] phyloseq_1.50.0         promises_1.3.2          digest_0.6.37          \n [10] mime_0.13               lifecycle_1.0.4         cluster_2.1.8.1        \n [13] ellipsis_0.3.2          survival_3.8-3          magrittr_2.0.3         \n [16] compiler_4.4.3          rlang_1.1.6             tools_4.4.3            \n [19] igraph_2.1.4            yaml_2.3.10             data.table_1.17.2      \n [22] knitr_1.50              htmlwidgets_1.6.4       curl_6.2.2             \n [25] pkgbuild_1.4.7          plyr_1.8.9              RColorBrewer_1.1-3     \n [28] pkgload_1.4.0           miniUI_0.1.1.1          purrr_1.0.4            \n [31] BiocGenerics_0.52.0     grid_4.4.3              stats4_4.4.3           \n [34] urlchecker_1.0.1        profvis_0.4.0           multtest_2.62.0        \n [37] biomformat_1.34.0       xtable_1.8-4            colorspace_2.1-1       \n [40] Rhdf5lib_1.28.0         ggplot2_3.5.2           scales_1.4.0           \n [43] iterators_1.0.14        MASS_7.3-65             dichromat_2.0-0.1      \n [46] cli_3.6.5               rmarkdown_2.29.1        vegan_2.6-10           \n [49] crayon_1.5.3            remotes_2.5.0           generics_0.1.4         \n [52] rstudioapi_0.17.1       httr_1.4.7              reshape2_1.4.4         \n [55] sessioninfo_1.2.3       ape_5.8-1               cachem_1.1.0           \n [58] rhdf5_2.50.2            stringr_1.5.1           zlibbioc_1.52.0        \n [61] splines_4.4.3           parallel_4.4.3          BiocManager_1.30.25    \n [64] XVector_0.46.0          vctrs_0.6.5             devtools_2.4.5         \n [67] Matrix_1.7-3            jsonlite_2.0.0          IRanges_2.40.1         \n [70] S4Vectors_0.44.0        foreach_1.5.2           glue_1.8.0             \n [73] codetools_0.2-20        stringi_1.8.7           gtable_0.3.6           \n [76] later_1.4.2             GenomeInfoDb_1.42.3     UCSC.utils_1.2.0       \n [79] tibble_3.2.1            pillar_1.10.2           htmltools_0.5.8.1      \n [82] rhdf5filters_1.18.1     GenomeInfoDbData_1.2.13 R6_2.6.1               \n [85] shiny_1.10.0            evaluate_1.0.3          lattice_0.22-7         \n [88] Biobase_2.66.0          openxlsx_4.2.8          memoise_2.0.1          \n [91] httpuv_1.6.15           Rcpp_1.0.14             zip_2.3.2              \n [94] nlme_3.1-168            permute_0.9-7           mgcv_1.9-3             \n [97] xfun_0.52               usethis_3.1.0           fs_1.6.6               \n[100] pkgconfig_2.0.3"
  },
  {
    "objectID": "0_setup.html#footnotes",
    "href": "0_setup.html#footnotes",
    "title": "Required Components",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nMamba is a reimplementation of Conda in C++ for speed and faster environment handling.↩︎"
  },
  {
    "objectID": "2_aodp.html",
    "href": "2_aodp.html",
    "title": "Run AODP for species level classification",
    "section": "",
    "text": "Identification of Rust Fungal Species through Metabarcoding and AODP"
  },
  {
    "objectID": "2_aodp.html#activate-conda-environment",
    "href": "2_aodp.html#activate-conda-environment",
    "title": "Run AODP for species level classification",
    "section": "Activate conda environment",
    "text": "Activate conda environment\n\n\n\n\n\n\nBASH Block\n\n\n\n\n\n# 1. (Optional) SSH into your remote server\nssh -Y ubuntu2204               # or yourname@your.remote.server\n\n# 2. Wrap in tmux to preserve the session\ntmux new -s aodp-training\n# …if disconnected:\n# ssh -Y ubuntu2204\n# tmux attach -t aodp-training\n\n# 3. Change to your working directory\ncd \"$wkdir\"\n\n# 4. List available environments and activate yours\nconda env list\nconda activate aodp-training\n\n# 5. Verify installation\nwhich aodp\naodp --help"
  },
  {
    "objectID": "2_aodp.html#run-aodp",
    "href": "2_aodp.html#run-aodp",
    "title": "Run AODP for species level classification",
    "section": "Run AODP",
    "text": "Run AODP\nTo runAODP, prepare a high-quality refDB in UNITE General Release format, here we use CR-ITS2-refDB.fasta in the refDBs folder. We will use “Pucciniales_asv.fasta” you have just created, which includes the representative sequences of all Pucciniales ASVs from the current study.\n\n\n\n\n\n\nBASH Block\n\n\n\n\n\n# Single oligo-size run\ntime aodp \\\n  --threads 8 \\\n  --match output/Pucciniales_asv.fasta \\\n  --oligo-size 16 \\\n  --match-output output/Pucciniales_asv.vs.CRITS2refDB.16.aodp \\\n  --max-homolo 0 \\\n  refDBs/CR-ITS2-refDB.fasta\n\n# Batch run over multiple oligo sizes\nfor os in 8 16 24; do\n  echo \"oligo-size = $os\"\n  time aodp \\\n    --threads 8 \\\n    --match output/Pucciniales_asv.fasta \\\n    --oligo-size \"$os\" \\\n    --match-output output/Pucciniales_asv.vs.CRITS2refDB.\"$os\".aodp \\\n    --max-homolo 0 \\\n    refDBs/CR-ITS2-refDB.fasta\ndone\n\n# 6. Inspect results\ncd output\nls -lh Pucciniales_asv.vs.CRITS2refDB*.aodp\n\n# Count and list identified Pucciniales ASVs\ngrep Pucciniales Pucciniales_asv.vs.CRITS2refDB.16.aodp \\\n  | cut -f1 \\\n  | sort -u \\\n  | tee Pucciniales_identified_asvs.txt \\\n  | wc -l\n\n# 7. (Optional) Deactivate when done\nconda deactivate"
  },
  {
    "objectID": "2_aodp.html#processing-aodp-outputs-in-r-to-obtain-taxonomic-classification",
    "href": "2_aodp.html#processing-aodp-outputs-in-r-to-obtain-taxonomic-classification",
    "title": "Run AODP for species level classification",
    "section": "Processing AODP outputs in R to obtain taxonomic classification",
    "text": "Processing AODP outputs in R to obtain taxonomic classification\n\n\n\n\n\n\nR Block\n\n\n\n\n# 0) Load required libraries ------------------------------------------------\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(phyloseq)\n\n# 1) Read & inspect raw AODP output ----------------------------------------\naodp_file &lt;- \"output/Pucciniales_asv.vs.CRITS2refDB.16.aodp\"\nranks     &lt;- c(\"kingdom\",\"phylum\",\"class\",\"order\",\"family\",\"genus\",\"species\",\"strain\")\n\n# 3rd quatile interspecific variation: 0.0152, \n# (1-0.0152)*100 = 98.2\nintraspecific_cutoff    &lt;- 98.2 \n\naodp &lt;- read.delim(\n  aodp_file,\n  header = FALSE,\n  col.names = c(\"ASV\",\"tax\",\"percent_identity\",\"match_length\",\n                \"ASV_length\",\"min_set\",\"largest_cluster\"),\n  stringsAsFactors = FALSE\n)\n\n# 2) Filter best hits & parse taxonomy -------------------------------------\naodp_filt &lt;- aodp %&gt;%\n  filter(tax != \"-\") %&gt;%                                 # drop no‐hits\n  mutate(\n    percent_identity = as.numeric(str_remove(percent_identity, \"%\")),        # \"xx.x%\" → numeric\n    tax     = str_remove(tax, \";$\")                       # drop trailing semicolon\n  ) %&gt;%\n  # keep only top‐hit per ASV, above your cutoff\n  group_by(ASV) %&gt;%\n  filter(percent_identity == max(percent_identity) & percent_identity &gt;= intraspecific_cutoff) %&gt;%\n  ungroup() %&gt;%\n  # split out “species|accession|desc|kingdom;…;strain”\n  separate(tax,\n           into = c(\"species1\",\"accession\",\"accession2\",\"desc\",\"taxonomy\"),\n           sep = \"\\\\|\",\n           extra = \"merge\", fill = \"right\",\n           remove = FALSE) %&gt;%\n  # turn the semicolon‐separated taxonomy into rank columns\n  mutate(taxonomy = str_remove_all(taxonomy, \"[dkpcofgst]__\")) %&gt;%\n  separate(taxonomy,\n           into = c(\"kingdom\",\"phylum\",\"class\",\"order\",\n                    \"family\",\"genus\",\"species\",\"strain\"),\n           sep = \";\",\n           fill = \"right\",\n           remove = FALSE) %&gt;%\n  select(-species1)\n\n# 3) Summarize unique values & counts per rank ----------------------------\nunique_tbl &lt;- aodp_filt %&gt;%\n  group_by(ASV, percent_identity) %&gt;%\n  summarise(\n    across(all_of(ranks),\n           ~ if (n_distinct(.x) == 1) unique(.x) else NA_character_),\n    .groups = \"drop\"\n  )\n\ncount_tbl &lt;- aodp_filt %&gt;%\n  group_by(ASV) %&gt;%\n  summarise(\n    across(all_of(ranks), n_distinct, .names = \"n_{.col}\"),\n    .groups = \"drop\"\n  )\n\nref_tbl &lt;- aodp_filt %&gt;%\n  group_by(ASV) %&gt;%\n  summarise(\n    refseq = paste(unique(tax), collapse = \",\"),\n    .groups = \"drop\"\n  )\n\n# 4) Compute LCA & rebuild full lineage -----------------------------------\nlca_tbl &lt;- unique_tbl %&gt;%\n  left_join(count_tbl, by = \"ASV\") %&gt;%\n  rowwise() %&gt;%\n  mutate(\n    lca_ix   = max(which(c_across(starts_with(\"n_\")) == 1)),\n    LCA_rank = ranks[lca_ix],\n    LCA_value = c_across(all_of(ranks))[lca_ix]\n  ) %&gt;%\n  mutate(\n    across(all_of(ranks), ~ {\n      pos &lt;- match(cur_column(), ranks)\n      if (pos &lt; lca_ix)    c_across(all_of(cur_column()))\n      else if (pos == lca_ix) LCA_value\n      else paste0(cur_column(), \"_undefined\")\n    })\n  ) %&gt;%\n  ungroup() %&gt;%\n  left_join(ref_tbl, by = \"ASV\") %&gt;%\n  rename_with(~ paste0(\"aodp.\", .x), -c(ASV, percent_identity, refseq))\n\n# 5) Identify ASVs dropped by filtering -----------------------------------\ndropped_asvs &lt;- tibble(ASV = unique(aodp$ASV)) %&gt;%\n  anti_join(lca_tbl, by = \"ASV\")\n\n# 6) Bundle & save final results ------------------------------------------\naodp_final &lt;- list(\n  assigned = as.data.frame(lca_tbl),\n  removed  = as.data.frame(dropped_asvs)\n)\n\nsaveRDS(aodp_final, \"output/aodp_final.RDS\")\n\n# Quick sanity checks\nhead(aodp_final$assigned[ , c(\"ASV\", \"aodp.species\")])\n\n                               ASV                         aodp.species\n1 01cacf96e7fa2e5878c556340e95a4fa Puccinia_coronata.VARavenaeFSPavenae\n2 03f65040eace36047cc5eb6e507e35c6         Puccinia_coronati.agrostidis\n3 05c6675f4aa67e096b63c32592fb6463            Puccinia_recondita.CladeX\n4 078d4add0e482cd30c534182c0a968d6    Puccinia_coronati.calamagrostidis\n5 07eed27dc85e519745652fb39aa4a969                 Puccinia_striiformis\n6 15a671eb88b1aa72fff8d0216e8322ae            Puccinia_graminis.CladeII\n\nhead(aodp_final$removed, 5)\n\n                               ASV\n1 4d9559ba3858a04ed426aca2a16a20c7\n2 af30d59db0971be9bf4845c2c9ffa539\n3 421e23034de1b2ba404dfcd8fef8b57d\n4 36a9adec4480a8f20b320162ae4c1559\n5 7d980b270e1ab4d7b9a407520da41ed3"
  },
  {
    "objectID": "2_aodp.html#modify-phyloseq-object-by-replace-the-species-level-classification-based-on-aodp",
    "href": "2_aodp.html#modify-phyloseq-object-by-replace-the-species-level-classification-based-on-aodp",
    "title": "Run AODP for species level classification",
    "section": "Modify phyloseq object by replace the species level classification based on AODP",
    "text": "Modify phyloseq object by replace the species level classification based on AODP\n\n\n\n\n\n\nR Block\n\n\n\n\n# 1) Load libraries ---------------------------------------------------------\nlibrary(phyloseq)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(stringr)\n\n# 2) Read in objects -------------------------------------------------------\nps_orig    &lt;- readRDS(\"output/phyloseq_rust.rds\")\naodp_final &lt;- readRDS(\"output/aodp_final.RDS\")\n\n# 3) Build new taxonomy table ---------------------------------------------\ntax_df &lt;- tax_table(ps_orig) %&gt;% \n  as.data.frame(stringsAsFactors = FALSE) %&gt;% \n  rownames_to_column(\"ASV\") %&gt;% \n  left_join(\n    aodp_final$assigned %&gt;% \n      select(ASV, aodp.family, aodp.genus, aodp.species),\n    by = \"ASV\"\n  ) %&gt;% \n  mutate(\n    # 3a) override family/genus if AODP provided\n    family = coalesce(aodp.family, family),\n    genus  = coalesce(aodp.genus,  genus),\n    # 3b) decide species: use AODP or fall back to genus_sp\n    genus_base = str_remove(genus, \"_sp$\"),\n    species    = if_else(\n      !is.na(aodp.species),\n      aodp.species,\n      paste0(genus_base, \"_sp\")\n    )\n  ) %&gt;% \n  select(kingdom, phylum, class, order, family, genus, species, ASV) %&gt;% \n  column_to_rownames(\"ASV\") %&gt;% \n  as.matrix()\n\n# 4) Swap taxonomy back into phyloseq --------------------------------------\nps_aodp &lt;- ps_orig\ntax_table(ps_aodp) &lt;- tax_table(tax_df)\n\n# 5) Sanity checks & save --------------------------------------------------\n# ensure no double “_sp_sp” artifacts\nstopifnot(!any(str_detect(tax_table(ps_aodp)[, \"species\"], \"_sp_sp\")))\n# peek at first two modified ASVs\ntax_table(ps_aodp)[aodp_final$assigned$ASV[1:2], ]\n\nTaxonomy Table:     [2 taxa by 7 taxonomic ranks]:\n                                 kingdom phylum          class            \n01cacf96e7fa2e5878c556340e95a4fa \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n03f65040eace36047cc5eb6e507e35c6 \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n                                 order         family         genus     \n01cacf96e7fa2e5878c556340e95a4fa \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n03f65040eace36047cc5eb6e507e35c6 \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n                                 species                               \n01cacf96e7fa2e5878c556340e95a4fa \"Puccinia_coronata.VARavenaeFSPavenae\"\n03f65040eace36047cc5eb6e507e35c6 \"Puccinia_coronati.agrostidis\"        \n\nsaveRDS(ps_aodp, \"output/phyloseq_rust_aodp.rds\")"
  }
]