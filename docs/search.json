[
  {
    "objectID": "4_rust.html",
    "href": "4_rust.html",
    "title": "Validation & Visualization",
    "section": "",
    "text": "Phylogenetic validation and seasonal trends of cereal rust fungi"
  },
  {
    "objectID": "4_rust.html#load-r-packages-quietly",
    "href": "4_rust.html#load-r-packages-quietly",
    "title": "Validation & Visualization",
    "section": "Load R packages quietly",
    "text": "Load R packages quietly\n\n\n\n\n\n\nR Block\n\n\n\n\n# 1. Load packages quietly ----------------------------------------------------\nlibrary(phyloseq)    # handling phyloseq objects\nlibrary(dplyr)       # data manipulation\nlibrary(tidyr)       # data manipulation\nlibrary(tibble)      # data manipulation\nlibrary(stringr)     # string operations\nlibrary(msa)         # multiple sequence alignment\nlibrary(Biostrings)  # DNAStringSet I/O\nlibrary(phangorn)    # phylogeny inference\nlibrary(ape)         # NJ tree, plotting utilities\nlibrary(ggplot2)     # plotting\nlibrary(ggtree)      # tree plotting\nlibrary(ggmsa)       # alignment inset\nlibrary(treeio)      # rescale_tree()\n\nlibrary(purrr)      # functional programming toolkit\nlibrary(cowplot)    # add-on to ggplot\n\npackageVersion(\"phyloseq\")\n\n[1] '1.50.0'\n\npackageVersion(\"ggmsa\")\n\n[1] '1.13.1'"
  },
  {
    "objectID": "4_rust.html#validating-aodp-classification-via-phylogenetic-tree-reconstruction",
    "href": "4_rust.html#validating-aodp-classification-via-phylogenetic-tree-reconstruction",
    "title": "Validation & Visualization",
    "section": "Validating AODP classification via phylogenetic tree reconstruction",
    "text": "Validating AODP classification via phylogenetic tree reconstruction\n\n\n\n\n\n\nR Block\n\n\n\n\n# ──────────────────────────────────────────────────────────────────────────────\n#  Phylogenetic analysis of Puccinia striiformis s.l. (ML tree + alignment)\n# ──────────────────────────────────────────────────────────────────────────────\n\n# 1. Define target species & import phyloseq ---------------------------------\nPst_sl &lt;- c(\n  \"Puccinia_striiformis\",\n  \"Puccinia_pseudostriiformis\",\n  \"Puccinia_striiformoides\"\n)\n\nps &lt;- readRDS(\"output/phyloseq_rust_aodp.rds\")\n\n# 2. Extract representative ASV sequences with new labels --------------------\nps_sub &lt;- subset_taxa(ps, species %in% Pst_sl)\nrep_seqs &lt;- refseq(ps_sub)\nnew_ids &lt;- tax_table(ps_sub) %&gt;%\n  as.data.frame(stringsAsFactors=FALSE) %&gt;%\n  rownames_to_column(\"ASV\") %&gt;%\n  mutate(newID = paste(species, \"|\", ASV, sep=\"\")) %&gt;%\n  pull(newID)\nnames(rep_seqs) &lt;- new_ids\n\n# 3. Load reference DB (incl. outgroup) & rename ------------------------------\nref_db &lt;- readDNAStringSet(\"refDBs/CR-ITS2-refDB.fasta\")\npattern &lt;- paste(Pst_sl, collapse=\"|\")\nref_sel &lt;- ref_db[grepl(pattern, names(ref_db)) |\n                    grepl(\"HM131236\", names(ref_db))] \nref_ids &lt;- names(ref_sel) %&gt;%\n  strsplit(\"\\\\|\") %&gt;%\n  map_chr(~ paste(.x[1:2], collapse=\"|\"))\nnames(ref_sel) &lt;- ref_ids\n\n# 4. Combine sequences & run MUSCLE -------------------------------------------\nall_seqs   &lt;- c(ref_sel, rep_seqs)\naln        &lt;- msa(all_seqs, method=\"Muscle\", order=\"input\")\naln_plain  &lt;- unmasked(aln)              # DNAStringSet\nalign_file &lt;- \"output/Pst_sl_rep.ref_align.fasta\"\nwriteXStringSet(aln_plain, align_file)\n\n# 5. Build maximum‐likelihood tree --------------------------------------------\nphydat &lt;- as.phyDat(aln, type=\"DNA\")\ndm     &lt;- dist.ml(phydat)\nnj0    &lt;- NJ(dm)\nfit0   &lt;- pml(nj0, data=phydat) %&gt;%\n  update(k=4, inv=0.2) %&gt;%\n  optim.pml(\n    model        = \"GTR\",\n    optInv       = TRUE,\n    optGamma     = TRUE,\n    rearrangement= \"stochastic\",\n    control      = pml.control(trace=0)\n  )\nml_tree        &lt;- root(\n  fit0$tree,\n  outgroup     = \"Puccinia_coronati.brevispora|HM131236\",\n  resolve.root = TRUE\n)\n\n# 6. Plot the ML tree --------------------------------------------------------\np_tree &lt;- ggtree(ml_tree) +\n  geom_tiplab(size=3) +\n  ggtitle(\"ML (GTR+Γ+I) tree of Pst s.l.\") +\n  theme_tree2()\nprint(p_tree)\n\n\n\n\n\n\n\n# 7. Add alignment facets -----------------------------------------------------\nmsa1 &lt;- tidy_msa(align_file, 170, 220)\nmsa2 &lt;- tidy_msa(align_file, 270, 320)\n\np_align &lt;- ggtree(rescale_tree(ml_tree, \"dN\"), branch.length=0) +\n  geom_tiplab(size=2.2, offset=0.001) +\n  theme_tree2() +\n  geom_facet(\n    geom    = geom_msa,\n    data    = msa1,\n    panel   = \"170–220 bp\",\n    font    = \"helvetical\",\n    color   = \"Chemistry_NT\"\n  ) +\n  geom_facet(\n    geom    = ggmsa:::geom_logo,\n    data    = msa1,\n    panel   = \"170–220 bp\",\n    mapping = aes(x=x, logo=char),\n    stat    = \"logo\",\n    color   = \"Chemistry_NT\",\n    adaptive= FALSE\n  ) +\n  geom_facet(\n    geom    = geom_msa,\n    data    = msa2,\n    panel   = \"270–320 bp\",\n    font    = \"helvetical\",\n    color   = \"Chemistry_NT\"\n  ) +\n  geom_facet(\n    geom    = ggmsa:::geom_logo,\n    data    = msa2,\n    panel   = \"270–320 bp\",\n    mapping = aes(x=x, logo=char),\n    stat    = \"logo\",\n    color   = \"Chemistry_NT\",\n    adaptive= FALSE\n  ) +\n  xlim_tree(2) +\n  theme(strip.text.x = element_text(size=14, face=\"bold\"))\n\nprint(p_align)\n\n\n\n\n\n\n\n# 8. Save the alignment+tree figure ------------------------------------------\nggsave(\n  filename = \"output/Pst_sl_ggtree.ggmsa.pdf\",\n  plot     = p_align,\n  width    = 10,\n  height   = 6\n)"
  },
  {
    "objectID": "4_rust.html#seasonal-dynamics-of-cereal-rust-species-in-bc-during-2015-2018",
    "href": "4_rust.html#seasonal-dynamics-of-cereal-rust-species-in-bc-during-2015-2018",
    "title": "Validation & Visualization",
    "section": "Seasonal dynamics of cereal rust species in BC during 2015-2018",
    "text": "Seasonal dynamics of cereal rust species in BC during 2015-2018\n\n\n\n\n\n\nR Block\n\n\n\n\n# 1. === Define your target rust species & nicer labels ===\ntarget &lt;- tribble(\n  ~code,                                   ~name,\n  \"Puccinia_coronata.VARavenaeFSPavenae\",  \"Puccinia coronata var. avenae f.sp. avenae\",\n  \"Puccinia_graminis.CladeII\",            \"Puccinia graminis CladeII\",\n  \"Puccinia_graminis.CladeIII\",           \"Puccinia graminis CladeIII\",\n  \"Puccinia_striiformis\",                 \"Puccinia striiformis\",\n  \"Puccinia_recondita.CladeIV\",           \"Puccinia recondita CladeIV\",\n  \"Puccinia_recondita.CladeVI\",           \"Puccinia recondita CladeVI\",\n  \"Puccinia_hordei.CladeI\",               \"Puccinia hordei CladeI\"\n)\n\n# 2. === Subset to BC & drop empty taxa/samples ===\n\nps &lt;- readRDS(\"output/phyloseq_rust_aodp.rds\")\n\nps_bc &lt;- ps %&gt;%\n  subset_samples(Province==\"BC\") %&gt;%\n  prune_taxa(taxa_sums(.)&gt;0, .) %&gt;%\n  prune_samples(sample_sums(.)&gt;0, .)\n\n# 3. === Build species‐by‐sample rel‐abundance table ===\nsp_ra &lt;- ps_bc %&gt;%\n  # extract tables\n  otu_table(., taxa_are_rows=TRUE) %&gt;% as.matrix() %&gt;% \n  as.data.frame() %&gt;% \n  rownames_to_column(\"ASV\") %&gt;%\n  left_join(\n    as.data.frame(tax_table(ps_bc)) %&gt;% rownames_to_column(\"ASV\") %&gt;% select(ASV, species),\n    by=\"ASV\"\n  ) %&gt;%\n  select(-ASV) %&gt;%\n  group_by(species) %&gt;%\n  summarise(across(everything(), sum), .groups=\"drop\") %&gt;%\n  column_to_rownames(\"species\") %&gt;%\n  t() %&gt;%                                   # now samples × species\n  sweep(1, rowSums(.), \"/\") %&gt;%             # rel‐abundance\n  as.data.frame() %&gt;%\n  rownames_to_column(\"SampleID\")\n\n# 4. === Pivot longer & join metadata ===\ndf_long &lt;- sp_ra %&gt;%\n  pivot_longer(\n    cols = any_of(target$code),\n    names_to  = \"SpeciesCode\",\n    values_to = \"RelAbund\"\n  ) %&gt;%\n  left_join(\n    ps_bc %&gt;% sample_data() %&gt;% \n      as.matrix() %&gt;%\n      as.data.frame() %&gt;% \n      rownames_to_column(\"SampleID\") %&gt;%\n      select(SampleID, Year, Sample_week, Month, SiteID),\n    by=\"SampleID\"\n  ) %&gt;%\n  mutate(\n    SpeciesName = target$name[match(SpeciesCode, target$code)],\n    SiteID      = factor(SiteID, levels=c(\"AG\",\"AR\",\"DC\"))\n  )\n\n\n# 5. === Compute monthly means & SE (%) ===\ndf_monthly &lt;- df_long %&gt;%\n  group_by(SpeciesCode, SpeciesName, Year, SiteID, Month) %&gt;%\n  summarise(\n    Mean   = mean(RelAbund, na.rm=TRUE)*100,\n    SE     = sd(RelAbund, na.rm=TRUE)/sqrt(n())*100,\n    .groups=\"drop\"\n  )\n\n# 6. === Function to make & save one plot ===\nmake_plot &lt;- function(code, name, label) {\n  dat &lt;- filter(df_monthly, SpeciesCode==code)\n  p &lt;- ggplot(dat, aes(x=Month, y=Mean, group=Year)) +\n    geom_line() +\n    geom_point() +\n    geom_errorbar(aes(ymin=Mean-SE, ymax=Mean+SE), width=0.2) +\n    facet_grid(SiteID~Year, scales=\"free_y\") +\n    labs(\n      subtitle = paste0(label, \") \", name),\n      x = \"Month\", y=\"Mean rel. abundance (%)\"\n    ) +\n    theme_minimal(base_size=12) +\n    theme(\n      strip.background = element_rect(fill=\"grey80\", color=\"black\"),\n      axis.text.x = element_text(angle=45, hjust=1),\n      plot.subtitle = element_text(face=\"bold\")\n    )\n  \n  # save\n  ggsave(\n    file.path(\"output\", sprintf(\"BC_%s_monthly.pdf\", code)),\n    plot = p, width=6, height=4\n  )\n  p\n}\n\n# 7. === Loop once to build all plots ===\n# What are the cereal rust species to be plotted?\npresent &lt;- levels(factor(df_monthly$SpeciesCode))\npresent &lt;- target[target$code %in% present, ]\nprint(present)\n\n# A tibble: 6 × 2\n  code                                 name                                     \n  &lt;chr&gt;                                &lt;chr&gt;                                    \n1 Puccinia_coronata.VARavenaeFSPavenae Puccinia coronata var. avenae f.sp. aven…\n2 Puccinia_graminis.CladeII            Puccinia graminis CladeII                \n3 Puccinia_graminis.CladeIII           Puccinia graminis CladeIII               \n4 Puccinia_striiformis                 Puccinia striiformis                     \n5 Puccinia_recondita.CladeVI           Puccinia recondita CladeVI               \n6 Puccinia_hordei.CladeI               Puccinia hordei CladeI                   \n\nlabels &lt;- toupper(letters[1:nrow(present)])\nplots &lt;- pmap(\n  list(present$code, present$name, labels),\n  make_plot\n) %&gt;% set_names(present$code)\n\n# 8. === Combine a subset as a grid for one figure ===\ngrid &lt;- plot_grid(\n  plotlist = plots[present$code], \n  ncol=3, nrow=3\n)\n\nggsave(\"output/BC_all_monthly.pdf\", grid, width=16, height=12)\n\nprint(plots$Puccinia_coronata.VARavenaeFSPavenae)\n\n\n\n\n\n\n\nprint(plots$Puccinia_striiformis)"
  },
  {
    "objectID": "2_data.html",
    "href": "2_data.html",
    "title": "Data used for this workshop",
    "section": "",
    "text": "Cereal rust fungi in western Canada"
  },
  {
    "objectID": "2_data.html#cereal-rust-fungi-and-field-sampling",
    "href": "2_data.html#cereal-rust-fungi-and-field-sampling",
    "title": "Data used for this workshop",
    "section": "Cereal rust fungi and field sampling",
    "text": "Cereal rust fungi and field sampling\nCereal rust fungi of the genus Puccinia cause significant yield losses in wheat, oat, barley, and rye. The most problematic species for wheat are P. graminis f. sp. tritici (stem rust), P. triticina (leaf rust), and P. striiformis f. sp. tritici (stripe rust). Other species like P. coronata and P. hordei affect oats and barley. Stem and leaf rust have been largely controlled in western Canada through resistance breeding and fungicides, but stripe rust has resurged due to temperature-adapted strains, leading to substantial yield losses. Rust spores typically travel from the southern U.S. and Mexico via the “Puccinia pathway” to Canada’s central and eastern prairies or the “Pacific pathway” to western prairies and the BC (Aboukhaddour et al. 2020; Brar et al. 2019).\nThe sequencing data used for this workshop were generated from airborne spore samples collected across cereal-growing regions in Western Canada as part of an integrated biovigilance framework (Chen et al. 2024). Air samples were collected by Burkard Cyclone spore samplers from three pilot sites in British Columbia during 2015-2018 and five sites in Alberta in 2018, western Canada (Figure 1). Airborne spores were systematically collected each week, spanning from April to November.\n\n\n\n\n\n\nFigure 1: Puccinia pathways and air-sampling sites in western Canada."
  },
  {
    "objectID": "2_data.html#wet-lab-prcoessing-and-sequncing-data-handling",
    "href": "2_data.html#wet-lab-prcoessing-and-sequncing-data-handling",
    "title": "Data used for this workshop",
    "section": "Wet-lab prcoessing and sequncing data handling",
    "text": "Wet-lab prcoessing and sequncing data handling\nGenomic DNA from the trapped spores (Figure 2) was extracted using a DNeasy PowerSoil DNA extraction kit (Qiagen) and a MP FastPrep-24 bead beater instrument (BioMedical). The ITS2 region was amplified using a rust-enhanced primer pair Rust2inv (5′-GAT GAA GAA CAC AGT GAA A-3′) and ITS4var_H (5′- TCC TCY GCT TAT TGA TAT GC-3′). The PCR products were sent to the Génome Québec Innovation Centre (Montréal, QC, Canada) for paired end PE300 sequencing using the Illumina MiSeq platform.\nThe raw sequencing data were processed using the DADA2 Divisive Amplicon Denoising pipeline wrapped in the Quantitative Insights Into Microbial Ecology version 2 (Qiime 2) bioinformatics suite (Estaki et al. 2020; Callahan et al. 2016), which allowed us to generate an Amplicon Sequence Variant (ASV) table. Alternatively, you can also run the DATA2 pipeline in the R environment. The ITS2 region of the representative sequences of the ASVs were extracted by ITSx (Bengtsson-Palme et al. 2013).\nWhile off-the-shelf taxonomic classifiers can reliably assign the short ITS2 reads to the fungal genus level, we used AODP to improve the species/subpecies-level resolution within cereal rust fungi by integrating a curated taxonomic references (CR-ITS2-refDB) and leveraging high-resolution variant detection within short amplicons, focusing on informative mutations even in highly conserved marker regions. AODP significantly improves the detection accuracy of rust fungi in environmental samples, advancing fungal biovigilance and transboundary pathogen surveillance.\n\n\n\n\n\n\nFigure 2: Air samples collected by Burkard cyclone sampler."
  },
  {
    "objectID": "2_data.html#prepare-data-for-aodp",
    "href": "2_data.html#prepare-data-for-aodp",
    "title": "Data used for this workshop",
    "section": "Prepare data for AODP",
    "text": "Prepare data for AODP\n\nImport QIIME2 outputs\n\n\n\n\n\n\nR Block\n\n\n\n\n# load libraries\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(Biostrings)\nlibrary(phyloseq)\n\n\n# import asv file\nasv &lt;- read.table(\"qiime2.outputs_and_metadata/feature-table.tsv\", sep = \"\\t\", header = TRUE, row.names = 1)\ndim(asv) \n\n[1] 11656   271\n\nhead(names(asv))\n\n[1] \"Ag.2015.30\" \"Ag.2015.35\" \"Ag.2015.29\" \"Ag.2015.32\" \"Ag.2015.31\"\n[6] \"Ag.2015.38\"\n\n\n\n# import q2 taxonomy \ntax &lt;- read.table (\"qiime2.outputs_and_metadata/taxonomy.tsv\", sep = \"\\t\", header = TRUE, row.names = 1) %&gt;%\n  mutate(Taxon=gsub(\"[dkpcofgs]__\", \"\", Taxon)) %&gt;%\n  separate(\n    col    = Taxon,\n    into   = c(\"kingdom\",\"phylum\",\"class\",\"order\",\"family\",\"genus\",\"species\"),\n    sep    = \";\",\n    fill   = \"right\",    # pad missing pieces on the right with NA\n    remove = TRUE       # remove the original Taxon column \n  ) %&gt;%\n  select(-Confidence) %&gt;%\n  # replace \"unidentified to NA\n  mutate(across(\n    kingdom:species,\n    ~ ifelse(is.na(.) | . == \"unidentified\", NA, .),  # (optional) re-NA any true missing\n    .names = \"{.col}\"\n  )) %&gt;%\n  # fix taxonomy to include LCA\n  # now build each rank via coalesce() on the *original* columns\n  mutate(\n    class   = coalesce(class,   paste0(phylum,  \"_sp\")),\n    order   = coalesce(order,   paste0(class,   \"_sp\")),\n    family  = coalesce(family,  paste0(order,   \"_sp\")),\n    genus   = coalesce(genus,   paste0(family,  \"_sp\")),\n    species = coalesce(species, paste0(genus,   \"_sp\"))\n  ) %&gt;%\n  mutate(across(\n    kingdom:species,\n    # collapse any run of \"_sp\" at the end into a single \"_sp\"\n    function(x) {\n      # collapse any run of \"_sp\" at the end into a single \"_sp\"\n      sub(\"(_sp)+$\", \"_sp\", x)\n    }\n  ))\n\ndim(tax) # 11645     7\n\n[1] 11645     7\n\nhead(tax)\n\n                                 kingdom        phylum           class\n0001e9647af93de910d25e693156fb6a   Fungi    Ascomycota   Ascomycota_sp\n000209c8100a89e11ab93ce320763e6f   Fungi Basidiomycota Tremellomycetes\n000c1ea6e5b1e40002e820be9528938a   Fungi    Ascomycota Dothideomycetes\n000cef60631bedcaee35214ebfb5d855   Fungi    Ascomycota Dothideomycetes\n0011c1d5dffe970a2bc0c83af2fa034a   Fungi Basidiomycota  Agaricomycetes\n00158b1404902009ce605322d92da764   Fungi Basidiomycota Pucciniomycetes\n                                         order            family         genus\n0001e9647af93de910d25e693156fb6a Ascomycota_sp     Ascomycota_sp Ascomycota_sp\n000209c8100a89e11ab93ce320763e6f   Tremellales       Bulleraceae   Genolevuria\n000c1ea6e5b1e40002e820be9528938a  Pleosporales     Periconiaceae     Periconia\n000cef60631bedcaee35214ebfb5d855   Venturiales Sympoventuriaceae    Ochroconis\n0011c1d5dffe970a2bc0c83af2fa034a   Polyporales       Meruliaceae       Phlebia\n00158b1404902009ce605322d92da764   Pucciniales   Coleosporiaceae    Chrysomyxa\n                                            species\n0001e9647af93de910d25e693156fb6a      Ascomycota_sp\n000209c8100a89e11ab93ce320763e6f     Genolevuria_sp\n000c1ea6e5b1e40002e820be9528938a       Periconia_sp\n000cef60631bedcaee35214ebfb5d855      Ochroconis_sp\n0011c1d5dffe970a2bc0c83af2fa034a Phlebia_margaritae\n00158b1404902009ce605322d92da764      Chrysomyxa_sp\n\n\n\n# load phylogenetic tree\ntree_file &lt;- \"qiime2.outputs_and_metadata/tree_rooted.nwk\"\ntree &lt;- ape::read.tree(tree_file)\ntree # 15668 tips\n\n\nPhylogenetic tree with 11656 tips and 11591 internal nodes.\n\nTip labels:\n  4e846c00c92f48052aef3c802497d67b, 553ba2eb7db09b15033a6587cbe0f82c, 75f9cdcc1402f6e1322ddbe426536d75, 079d917301099c1b611b88f27d6a6269, ab2e014068378c5694ea24ad313e3147, 5811498736402e36b957197cd33dd3b7, ...\nNode labels:\n  0.307, 0.996, 0.910, 1.000, 0.565, 0.863, ...\n\nRooted; includes branch length(s).\n\n\n\n# load ASV representative sequences\nrep_file &lt;- \"qiime2.outputs_and_metadata/rep-seqs_ITS2.fasta\"\nrep &lt;- Biostrings::readDNAStringSet(rep_file)\nrep # 15395\n\nDNAStringSet object of length 15395:\n        width seq                                           names               \n    [1]   167 CACCAATCAAGCTCTGCTTGG...AAAACACCAATACATCAAAGG 0001e9647af93de91...\n    [2]   180 AAAATCAATCCCCACGGGTTT...CCTCGGGCAACTACTTTTTGC 000209c8100a89e11...\n    [3]   158 ACACCTTCAAGCCTAGCTTGG...CCAGCAAGCTACTTTTATGAC 000c1ea6e5b1e4000...\n    [4]   177 CACACCCCAAGCTGTGCTTGA...TGAACAACTTCTAAACAAAGT 000cef60631bedcae...\n    [5]   195 AATCCTCAACCCTCCCTCCCT...TTCGGGACAGCTTTTTCGAAT 0011c1d5dffe970a2...\n    ...   ... ...\n[15391]   204 AATTCTCAACCTCACCAGTTT...CAAGGACAATACCTTGACAAT ffe3f8e4e92f49518...\n[15392]   150 CACCACTCAAGCCTCGCTTGG...AAAACAACCCCATTTCTAAGG ffe8f1b7a999794ef...\n[15393]   157 TCAACCATCAAGCTCTGCTTG...CCAAAACCCATCACCTCAAGG ffe961af85fa9b3f7...\n[15394]   200 GAACACATCACCTCCCTTAGG...CGGGGACCATCTTTTTACGCT fff2e443e70df58fb...\n[15395]   215 AACCCTCTCATTAAACAATTT...AAACCCATACATTTTATTTTT fff392eb19c184f98...\n\n# Filter for sequences with width ≥ 100 bp\nrep_filtered &lt;- rep[width(rep) &gt;= 100]\n\n# Check how many are retained\nlength(rep_filtered) # 15291\n\n[1] 15291\n\nsource(\"./scripts/functions.R\")\n\ncolor_dna(rep_filtered, n = 5)\n\n[1] 167 bp  0001e9647af93de910d25e693156fb6a  CACCAATCAAGCTCTGCTTGGTATTGGGCCCTCGTCCCCCCCCTCGCGGGGGGGTCGTGCCCCGAAACATTCGGCGAAGTCACATCGGCTTTGGGCGTAGTAGAATTTCCATAACGTTCACGAGTCCGGCGAGGCCTTCTGCCGCAAAAACACCAATACATCAAAGG\n[2] 180 bp  000209c8100a89e11ab93ce320763e6f  AAAATCAATCCCCACGGGTTTCTGACCCGGCGGTGGACTTGGAGTTGGGCGTCTGCCGGTCACACGGCTCGCCTCAAAGACCTTAGTGGGAACATCGGCCTATGGCTTGACGTAATAAGTTTCGTCTCGCACGGTCGGTGACGCCTGCTCACAACCAGCCCTCGGGCAACTACTTTTTGC\n[3] 158 bp  000c1ea6e5b1e40002e820be9528938a  ACACCTTCAAGCCTAGCTTGGTGTTGGGCGTCTGTCCCGCACTCGTTGCGCGGACTCGCCTCAAAGTCATTGGCGGCGGTCGTGCCGGCTCCTCGCGCAGCACATTTGCGCTTCTCGGAGGCCCGGCGGATCAGCATCCAGCAAGCTACTTTTATGAC\n[4] 177 bp  000cef60631bedcaee35214ebfb5d855  CACACCCCAAGCTGTGCTTGATGTTGGACGCTGTCTGTGAAAGGACAGGTCTGGAACGCGTGGGCGCCGCCGCCGGACCACGAGCGTAGCAAGACGCAAGTCATTCGCTGTGTGGAATCTGGTGGGTGGTGGCCGTTGTGGCGGGTAAGACCGACATGAACAACTTCTAAACAAAGT\n[5] 195 bp  0011c1d5dffe970a2bc0c83af2fa034a  AATCCTCAACCCTCCCTCCCTTGTGGACGGGATGGGCTTGGAATTGGAGGTCTTGCCGTCCGTAGTGGTCGGCTCCTCTCAAATGCATTAGCTCGGTTCTTAGCGGATCGGCTCCCGGCGTGATAATTGTCTACGTCGCGACCGTGAAGCGTCTGGCCGGCTTCCAATCGTCCCTTCGGGACAGCTTTTTCGAAT\n\n\n\n\n\n\nImport metadata\n\n\n\n\n\n\nR Block\n\n\n\n\n# load metadata\nmeta &lt;- openxlsx::read.xlsx(\"qiime2.outputs_and_metadata/meta.xlsx\", rowNames = TRUE)\nhead(meta[, 1:5])\n\n           Year SiteID       Date Month Sample_week\nAg.2015.30 2015     AG 2015-07-24     7          30\nAg.2015.35 2015     AG 2015-08-28     8          35\nAg.2015.29 2015     AG 2015-07-17     7          29\nAg.2015.32 2015     AG 2015-08-07     8          32\nAg.2015.31 2015     AG 2015-07-31     7          31\nAg.2015.38 2015     AG 2015-09-18     9          38\n\ndim(meta)\n\n[1] 271  12"
  },
  {
    "objectID": "2_data.html#create-phyloseq-object",
    "href": "2_data.html#create-phyloseq-object",
    "title": "Data used for this workshop",
    "section": "Create phyloseq object",
    "text": "Create phyloseq object\n\n\n\n\n\n\nR Block\n\n\n\n\n# create phyloseq object\nps_ASV &lt;- otu_table(asv, taxa_are_rows = TRUE)\nps_TAX &lt;- tax_table(as.matrix(tax))\nps_META &lt;- sample_data(meta)\nps &lt;- phyloseq(ps_ASV, ps_TAX) %&gt;%\n         merge_phyloseq(., ps_META) %&gt;%\n         merge_phyloseq(., tree) %&gt;%\n         merge_phyloseq(., rep)\nps\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 11645 taxa and 271 samples ]\nsample_data() Sample Data:       [ 271 samples by 12 sample variables ]\ntax_table()   Taxonomy Table:    [ 11645 taxa by 7 taxonomic ranks ]\nphy_tree()    Phylogenetic Tree: [ 11645 tips and 11580 internal nodes ]\nrefseq()      DNAStringSet:      [ 11645 reference sequences ]\n\nsaveRDS(ps, \"output/phyloseq_all.rds\")"
  },
  {
    "objectID": "2_data.html#subset-the-rust-fungal-community",
    "href": "2_data.html#subset-the-rust-fungal-community",
    "title": "Data used for this workshop",
    "section": "Subset the rust fungal community",
    "text": "Subset the rust fungal community\n\n\n\n\n\n\nR Block\n\n\n\n\nps &lt;- readRDS(\"output/phyloseq_all.rds\")\n\n# Subset rust fungal community only\nps.rust &lt;- subset_taxa(ps, order == \"Pucciniales\") %&gt;%\n              # remove ASVs with zero reads\n              prune_taxa(taxa_sums(.) &gt; 0, . ) %&gt;%\n              # remove samples with zero reads\n              prune_samples(sample_sums(.) &gt; 0, .)\n\nps.rust\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 768 taxa and 242 samples ]\nsample_data() Sample Data:       [ 242 samples by 12 sample variables ]\ntax_table()   Taxonomy Table:    [ 768 taxa by 7 taxonomic ranks ]\nphy_tree()    Phylogenetic Tree: [ 768 tips and 767 internal nodes ]\nrefseq()      DNAStringSet:      [ 768 reference sequences ]\n\nhead(tax_table(ps.rust)[tax_table(ps.rust)[, \"genus\"]==\"Puccinia\", ])\n\nTaxonomy Table:     [6 taxa by 7 taxonomic ranks]:\n                                 kingdom phylum          class            \n4ab5d797219ea5306ebce5f0333fe2be \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n4d483466236a2e113140e36e7de6499c \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n640c996f4e4765310497bd1244973f82 \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\nb006dbb25ca81c89d73fe86032f9c03a \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\nce65fe6eeeb329fafee9e548f1723502 \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n4fe30f4670ab9c998662afe56de8aa3b \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n                                 order         family         genus     \n4ab5d797219ea5306ebce5f0333fe2be \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n4d483466236a2e113140e36e7de6499c \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n640c996f4e4765310497bd1244973f82 \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\nb006dbb25ca81c89d73fe86032f9c03a \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\nce65fe6eeeb329fafee9e548f1723502 \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n4fe30f4670ab9c998662afe56de8aa3b \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n                                 species                \n4ab5d797219ea5306ebce5f0333fe2be \"Puccinia_sp\"          \n4d483466236a2e113140e36e7de6499c \"Puccinia_sp\"          \n640c996f4e4765310497bd1244973f82 \"Puccinia_tanaceti\"    \nb006dbb25ca81c89d73fe86032f9c03a \"Puccinia_tanaceti\"    \nce65fe6eeeb329fafee9e548f1723502 \"Puccinia_tanaceti\"    \n4fe30f4670ab9c998662afe56de8aa3b \"Puccinia_punctiformis\"\n\nsaveRDS(ps.rust, \"output/phyloseq_rust.rds\")"
  },
  {
    "objectID": "2_data.html#export-representative-sequences-of-rust-fungi",
    "href": "2_data.html#export-representative-sequences-of-rust-fungi",
    "title": "Data used for this workshop",
    "section": "Export representative sequences of rust fungi",
    "text": "Export representative sequences of rust fungi\n\n\n\n\n\n\nR Block\n\n\n\n\n# keep sequences longer than 100 bp\nrep.rust &lt;- refseq(ps.rust) %&gt;%\n  { .[width(.) &gt;= 100] }\n\n# Write Pucciniales representative sequences  \nBiostrings::writeXStringSet(rep.rust, \"output/Pucciniales_asv.fasta\", \n                            append=FALSE, width=20001,\n                            compress=FALSE, \n                            compression_level=NA, \n                            format=\"fasta\")"
  },
  {
    "objectID": "0_setup.html",
    "href": "0_setup.html",
    "title": "Required Components",
    "section": "",
    "text": "Identification of Rust Fungal Species through Metabarcoding and AODP\nYOU MUST COMPLETE THE ENVIRONMENT SETUP BEFORE ATTENDING THE WORKSHOP."
  },
  {
    "objectID": "0_setup.html#operating-system",
    "href": "0_setup.html#operating-system",
    "title": "Required Components",
    "section": "💻 Operating System",
    "text": "💻 Operating System\nYou should use a laptop with Linux operational system for this workshop.\nWindows users should install a Linux virtual machine via VirtualBox or use WSL2."
  },
  {
    "objectID": "0_setup.html#conda-or-mamba-setup",
    "href": "0_setup.html#conda-or-mamba-setup",
    "title": "Required Components",
    "section": "🐍 Conda or Mamba Setup",
    "text": "🐍 Conda or Mamba Setup\nWe will use Conda (or Mamba)1 to manage software environments.\n\nRecommended: Mambaforge\nAlternative: Miniconda\n\n\n✅ Test your installation:\n\n\n\n\n\n\nBASH Block\n\n\n\n\nwhich conda\nconda --version\n\nwhich mamba\nmamba --version\n\n#-------------------\n# If your shell hasn’t been properly initialized for Mamba to manage environments like conda activate does.\n# do the following steps:\n#-------------------\n# 1. obtain mamba base environment: \nmamba info\n# from the output, find \"base environment : /gpfs/fs7/aafc/labs/chenw_lab/code/software/mambaforge\"\n\n# 2. run the following command ONCE, replace the path to your own mamba base environment\n# mamba shell init --shell bash --root-prefix=/gpfs/fs7/aafc/labs/chenw_lab/code/software/mambaforge\n\n# 3. Then restart your terminal or run:\n# source ~/.bashrc \n\n# To set mamba as the default (for its performance)\n# add this to your ~/.bashrc\n# export PATH=\"/gpfs/fs7/aafc/labs/chenw_lab/code/software/mambaforge/bin:$PATH\"\n# source ~/.bashrc"
  },
  {
    "objectID": "0_setup.html#git-installation",
    "href": "0_setup.html#git-installation",
    "title": "Required Components",
    "section": "🔧 Git Installation",
    "text": "🔧 Git Installation\nGit is a version control system used to track changes and collaborate on data projects, including scripts, data, figures, and documents.\n📌 Install Git for your operating system.\n\n\n\n\n\n\nBASH Block\n\n\n\n\n\n# 1. clone the github repository\ngit clone https://github.com/WenChenAAFC/rust_fungi_identification_using_metabarcoding_and_AODP.git\n\n# 2. switch to the working directory\ncd rust_fungi_identification_using_metabarcoding_and_AODP\n\n# 3. get the path of the working directory\nwkdir=`pwd` # NO space\necho $wkdir\nls -lah\n\n# 4. Examine the folder structure;\n# if you do not have tree command in the system\nfind . -type d | sed -e 's/[^-][^\\/]*\\//|   /g' -e 's/| *\\([^|]\\)/+-- \\1/'\n# Lists all directories (find . -type d)\n# Replaces each /-based level with indentation (| )\n# Marks the final directory component with a +-- to mimic the tree command."
  },
  {
    "objectID": "0_setup.html#installing-aodp-with-dependencies-and-other-tools",
    "href": "0_setup.html#installing-aodp-with-dependencies-and-other-tools",
    "title": "Required Components",
    "section": "⚙️ Installing AODP with dependencies and other tools",
    "text": "⚙️ Installing AODP with dependencies and other tools\n\n\n\n\n\n\nBASH Block\n\n\n\n\n\n# Check your working directory, should be PATH_TO/rust_fungi_identification_using_metabarcoding_and_AODP\necho $wkdir\ncd $wkdir\n\n# 1. (Optional) Reinstall mamba if it’s misbehaving\n# conda activate base\n# conda remove mamba --yes\n# conda clean --all --yes\n# conda install -c conda-forge mamba --yes\n\n# 2. (Optional) Remove any old training env, for example:\n# mamba env remove -n aodp-training --yes\n\n# 3. Create a fresh aodp-training env with the core dependencies\nmamba create -n aodp-training -c conda-forge -c bioconda \\\n  gcc_linux-64=10.4.0 \\\n  gxx_linux-64=10.4.0 \\\n  make \\\n  perl \\\n  perl-bioperl \\\n  blast \\\n  --yes\n\n# 4. (Optional) Add ITSx\nmamba install -n aodp-training -c conda-forge -c bioconda itsx --yes\nwhich ITSx\n\n# 5. Activate and verify\nmamba activate aodp-training\n\n# 5a. Check Perl\nwhich perl\nperl -MBio::Seq -e 'print \"Bioperl is working\\n\";' \\\n  || { \n       export PATH=\"$CONDA_PREFIX/bin:$PATH\"; \n       hash -r; \n       which perl; \n       perl -MBio::Seq -e 'print \"Bioperl is working\\n\";' \n     }\nmamba list perl-bioperl\n\n# 6. Build & install AODP\ncd aodp_v2.0_release\ntar xvf aodp-2.5.0.1.tar.gz\ncd aodp-2.5.0.1\n\nexport CXXFLAGS=\"-std=c++11\"\n./configure \\\n  BIN_TARGET_DIR=\"$PWD\" \\\n  MAN_TARGET_DIR=\"$PWD/man\"\n\nmake clean && make\nmake install\n\n# 7. Temporally add aodp to PATH\nexport PATH=\"$PATH:$PWD\"; # \n\n# 8. to permanently add aodp to PATH,\n# add above line to your ~/.bashrc \n# e.g. add \"export PATH=\"$PATH:/gpfs/fs7/aafc/labs/chenw_lab/workspace/chenw/RustIDing_using_metabarcoding_and_AODP/aodp_v2.0_release/aodp-2.5.0.1\"\n# source ~/.bashrc\n\n# 8. Test installation\nwhich aodp\naodp --help\n\n#------------------------------\n# 9. (Optonal) check other software installed, \n#------------------------------\n# [ITSx is an open source software utility to extract the highly variable ITS1 and ITS2 subregions from ITS sequences, which is commonly used as a molecular barcode for e.g. fungi.](https://microbiology.se/software/itsx/)\nwhich ITSx\nITSx --help\n\n# To deactivate environment\nmamba deactivate"
  },
  {
    "objectID": "0_setup.html#review-other-data-folders-and-accessory-scripts",
    "href": "0_setup.html#review-other-data-folders-and-accessory-scripts",
    "title": "Required Components",
    "section": "🧬 Review other data folders and accessory scripts",
    "text": "🧬 Review other data folders and accessory scripts\n\n\n\n\n\n\nBASH Block\n\n\n\n\n\n# 1. QIIME2 outputs\nls -lah qiime2.outputs_and_metadata\n\n# 2. The Rust ITS2 Database \nls -lah refDBs \n# find CR-ITS2-refDB -this is a high-quality, curated ITS2 reference database for cereal rust fungal species or species complexes, compiled by Dr. Sarah Hambleton [@RN3722]\n\n# 3. Additional R functions\nls -lah scripts  \n# find function.R — this script contain an R function that wraps DNA sequences in HTML spans with nucleotide-specific colors, and then prints them using the htmltools::HTML() function so Quarto renders it with full color in HTML output.\n\ntotal 24320\ndrwxr-xr-x@  8 chenw  staff   256B May 25 19:10 .\ndrwxr-xr-x@ 34 chenw  staff   1.1K May 29 12:52 ..\n-rw-rw-r--@  1 chenw  staff   6.0K May 23 12:23 .DS_Store\n-rw-rw-r--@  1 chenw  staff   6.4M Apr  6 03:26 feature-table.tsv\n-rw-rw-r--@  1 chenw  staff    24K May 23 10:14 meta.xlsx\n-rw-rw-r--@  1 chenw  staff   3.1M Mar 14  2022 rep-seqs_ITS2.fasta\n-rw-rw-r--@  1 chenw  staff   1.7M May  2 17:02 taxonomy.tsv\n-rw-rw-r--@  1 chenw  staff   675K Apr  6 03:37 tree_rooted.nwk\ntotal 1304\ndrwxr-xr-x@  4 chenw  staff   128B May 22 09:40 .\ndrwxr-xr-x@ 34 chenw  staff   1.1K May 29 12:52 ..\n-rw-rw-r--@  1 chenw  staff   370K May  2 14:18 CR-ITS2-refDB.align.fasta\n-rw-rw-r--@  1 chenw  staff   279K May  2 14:17 CR-ITS2-refDB.fasta\ntotal 24\ndrwxr-xr-x@  4 chenw  staff   128B May 23 09:28 .\ndrwxr-xr-x@ 34 chenw  staff   1.1K May 29 12:52 ..\n-rw-r--r--@  1 chenw  staff   6.0K May 23 09:26 .DS_Store\n-rw-rw-r--@  1 chenw  staff   1.1K May 23 09:28 functions.R"
  },
  {
    "objectID": "0_setup.html#r-and-rstudio-setup",
    "href": "0_setup.html#r-and-rstudio-setup",
    "title": "Required Components",
    "section": "📊 R and RStudio Setup",
    "text": "📊 R and RStudio Setup\n\nInstall R and RStudio\n\n\nR\nRStudio Desktop\n\n\nInstalling the required R packages\n\n\n\n\n\n\n\nR Block\n\n\n\n\n# 1. CRAN packages\nrequired_cran &lt;- c(\"openxlsx\", # Read, write, and edit Microsoft Excel file\n                   \"dplyr\", # data manipulation: filter, select, mutate, summarize, join, etc.\n                   \"tidyr\", # turning “messy” data into tidy data frames.\n                   \"stringr\", # simple wrappers for string operations (pattern matching, replacement, etc.).\n                   \"tibble\",  # Modern reimagining of data.frame: better printing, stricter checks, etc\n                   \"splitstackshape\", # Stack and reshape datasets after splitting concatenated values\n                   \"purrr\", # Functional-programming tools for working with lists/vectors.\n                   \"ggplot2\", # creating graphics, based on “The Grammar of Graphics.\n                   \"cowplot\", # Extensions to ggplot2 for arranging multiple plots and adding annotations.\n                   \"ape\", # Analyses of phylogenetics and evolution: tree manipulation, plotting, etc\n                   \"phangorn\" # Phylogenetic inference and evolutionary analyses\n                   )\nif (!requireNamespace(required_cran, quietly = TRUE)) {\n  install.packages(required_cran, repos = \"http://cran.rstudio.com\", dependencies = TRUE)\n}\n\n\n# 2. Bioconda packages:\nif (!requireNamespace(\"BiocManager\", quietly = TRUE)) {\n  install.packages(\"BiocManager\")\n}\n\nrequired_bioc &lt;- c(\"phyloseq\", # Import, store, analyze and graph microbiome census data (OTUs, taxonomy, phylogeny, sample data).\n                    \"Biostrings\", # Efficient containers and utilities for biological sequences (DNA, RNA, AA strings).\n                   \"ggtree\", # Grammar-of-graphics plotting and annotation of phylogenetic trees.\n                   \"msa\", # Interface to multiple sequence alignment algorithms (ClustalW/Omega, MUSCLE) in R.\n                   \"ggmsa\", # Alignment visualization in a ggplot2-style (sequence and tree insets).\n                   \"treeio\" # Import, export, and manipulate richly annotated phylogenetic tree formats (e.g. Newick, Nexus).\n                   )\nif (!requireNamespace(required_bioc, quietly = TRUE)) {\n  BiocManager::install(required_bioc)\n}\n\n\n# 3. Alternatively, # 3. Install ggmsa from GitHub via devtools\nif (!requireNamespace(\"devtools\", quietly = TRUE)) {\n  install.packages(\"devtools\")\n}\ndevtools::install_github(\"YuLab-SMU/ggmsa\")\n\nUsing GitHub PAT from the git credential store.\n\n\nSkipping install of 'ggmsa' from a github remote, the SHA1 (b90d4b9f) has not changed since last install.\n  Use `force = TRUE` to force installation\n\n# Verify installation\npackageVersion(\"ggmsa\") \n\n[1] '1.13.1'\n\n# 4. Check your R session\nsessionInfo() # This command will tell you information about your current R session\n\nR version 4.4.3 (2025-02-28)\nPlatform: x86_64-apple-darwin20\nRunning under: macOS Sequoia 15.5\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/Toronto\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n  [1] ade4_1.7-23             tidyselect_1.2.1        dplyr_1.1.4            \n  [4] farver_2.1.2            Biostrings_2.74.1       fastmap_1.2.0          \n  [7] phyloseq_1.50.0         promises_1.3.2          digest_0.6.37          \n [10] mime_0.13               lifecycle_1.0.4         cluster_2.1.8.1        \n [13] ellipsis_0.3.2          survival_3.8-3          magrittr_2.0.3         \n [16] compiler_4.4.3          rlang_1.1.6             tools_4.4.3            \n [19] igraph_2.1.4            yaml_2.3.10             data.table_1.17.2      \n [22] knitr_1.50              htmlwidgets_1.6.4       curl_6.2.2             \n [25] pkgbuild_1.4.7          plyr_1.8.9              RColorBrewer_1.1-3     \n [28] pkgload_1.4.0           miniUI_0.1.1.1          purrr_1.0.4            \n [31] BiocGenerics_0.52.0     grid_4.4.3              stats4_4.4.3           \n [34] urlchecker_1.0.1        profvis_0.4.0           multtest_2.62.0        \n [37] biomformat_1.34.0       xtable_1.8-4            colorspace_2.1-1       \n [40] Rhdf5lib_1.28.0         ggplot2_3.5.2           scales_1.4.0           \n [43] iterators_1.0.14        MASS_7.3-65             dichromat_2.0-0.1      \n [46] cli_3.6.5               rmarkdown_2.29.1        vegan_2.6-10           \n [49] crayon_1.5.3            remotes_2.5.0           generics_0.1.4         \n [52] rstudioapi_0.17.1       httr_1.4.7              reshape2_1.4.4         \n [55] sessioninfo_1.2.3       ape_5.8-1               cachem_1.1.0           \n [58] rhdf5_2.50.2            stringr_1.5.1           zlibbioc_1.52.0        \n [61] splines_4.4.3           parallel_4.4.3          BiocManager_1.30.25    \n [64] XVector_0.46.0          vctrs_0.6.5             devtools_2.4.5         \n [67] Matrix_1.7-3            jsonlite_2.0.0          IRanges_2.40.1         \n [70] S4Vectors_0.44.0        foreach_1.5.2           glue_1.8.0             \n [73] codetools_0.2-20        stringi_1.8.7           gtable_0.3.6           \n [76] later_1.4.2             GenomeInfoDb_1.42.3     UCSC.utils_1.2.0       \n [79] tibble_3.2.1            pillar_1.10.2           htmltools_0.5.8.1      \n [82] rhdf5filters_1.18.1     GenomeInfoDbData_1.2.13 R6_2.6.1               \n [85] shiny_1.10.0            evaluate_1.0.3          lattice_0.22-7         \n [88] Biobase_2.66.0          openxlsx_4.2.8          memoise_2.0.1          \n [91] httpuv_1.6.15           Rcpp_1.0.14             zip_2.3.2              \n [94] nlme_3.1-168            permute_0.9-7           mgcv_1.9-3             \n [97] xfun_0.52               usethis_3.1.0           fs_1.6.6               \n[100] pkgconfig_2.0.3"
  },
  {
    "objectID": "0_setup.html#footnotes",
    "href": "0_setup.html#footnotes",
    "title": "Required Components",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nMamba is a reimplementation of Conda in C++ for speed and faster environment handling.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The workshop",
    "section": "",
    "text": "This workshop is prepared for the joint 17th International Cereal Rusts and Powdery Mildews Conference (ICRPMC2025), the Canadian Phytopathological Society (CPS) Annual Meeting, and the Bourlag Global Rust Initiative (BGRI)Technical Workshop scheduled for June 15-20, 2025 in Vancouver, British Columbia at the at UBC Vancouver campus."
  },
  {
    "objectID": "index.html#workshop-organizing-committee",
    "href": "index.html#workshop-organizing-committee",
    "title": "The workshop",
    "section": "Workshop organizing committee",
    "text": "Workshop organizing committee\n\nLead workshop organiser, preparation of workshop material and website\n\nWen Chen - wen.chen@agr.gc.ca, wchen@uottawa.ca\n\n\n\nInstructors\n\nSamuel Holden sholden1@ualberta.ca\nDavid Kim david.kim2@agr.gc.ca\nSean Formby sean.formby@gmail.com; sean.formby@gmail.com\n\n\n\nScientific advisors\n\nGuus Bakkeren guus.bakkeren@AGR.GC.CA;\nSean Li sean.li@inspection.gc.ca sean.li@inspection.gc.ca;\nGurcharn Brar gurcharn@ualberta.ca"
  },
  {
    "objectID": "index.html#special-notification",
    "href": "index.html#special-notification",
    "title": "The workshop",
    "section": "Special Notification",
    "text": "Special Notification\nThis workshop provides hands-on training in bioinformatic approaches for accurate identification and classification of phytopathogens at the species or subspecies level using metabarcoding short reads from environmental samples. While the case study focuses on cereal rust fungi detected in air samples, the concepts and workflows presented are broadly applicable and can be adapted to other pathogens and sample types.\nThe workshop is intended for participants with prior experience using command-line tools and the Linux operating system. It is not suitable for those seeking an introduction to Linux. Participants must bring their own laptops equipped with either a Linux virtual machine (e.g., via VirtualBox) or remote access to a Linux-based high-performance computing (HPC) server. Detailed setup instructions are provided in the Environment Setup section, and all required software and environments must be installed before the workshop begins."
  },
  {
    "objectID": "1_intro.html",
    "href": "1_intro.html",
    "title": "Introduction",
    "section": "",
    "text": "AODP advances diagnostic metagenomics for plant pathogens through metabarcoding"
  },
  {
    "objectID": "1_intro.html#diagnostic-metagenomics-in-plant-pathology",
    "href": "1_intro.html#diagnostic-metagenomics-in-plant-pathology",
    "title": "Introduction",
    "section": "Diagnostic Metagenomics in Plant Pathology",
    "text": "Diagnostic Metagenomics in Plant Pathology\nDiagnostic metagenomics (Figure 1) refers to the use of untargeted, high-throughput sequencing approaches to identify and characterize all nucleic acids present in a sample, enabling the detection of known, unexpected, and novel pathogens without prior knowledge of their presence. In plant pathology, diagnostic metagenomics has emerged as a powerful tool for comprehensive pathogen (Table 1) detection, disease diagnosis, and surveillance. It allows for the identification of multiple pathogens—fungi, bacteria, viruses, and oomycetes—from complex plant tissues, soil, or environmental samples in a single assay. This approach has been applied in disease outbreak investigations, certification programs, and quarantine enforcement, enabling early detection of regulated or emerging pathogens. Moreover, metagenomic data are increasingly integrated into biovigilance frameworks (Figure 2), which monitor pathogen dynamics across space and time, track potential inoculum sources, and support risk assessment for transboundary pest movement. As sequencing technologies and bioinformatics tools continue to advance, diagnostic metagenomics is poised to become a cornerstone of modern plant health monitoring and biosecurity.\n\n\n\nTable 1: Estimated Number of Pathogenic Species and Regulated Pathogens by CFIA and USDA\n\n\n\n\n\n\n\n\n\n\n\nPathogen Type\nEstimated Pathogenic spp.\nRegulated spp. (CFIA)\nRegulated spp. (USDA)\n\n\n\n\nFungi\n&gt; 20K\n&gt; 45\n582\n\n\nOomycetes\n~ 1K\n~ 150\n18\n\n\nBacteria\n200\n13\n0.26\n\n\nNematodes\n4K\n9\n?\n\n\nViruses\n1K\n69\n27\n\n\nOther\n\n~ 141\n&gt; 6K\n\n\nTotal\n\n&gt; 290\n&gt; 6919\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Schematic workflow of diagnostic metagenomics, from the field to wet-lab.\n\n\n\n\n\n\n\n\n\nFigure 2: AeroNET: A Canadian biovigilance framework integrating spore trapping, metagenomic diagnostics, and wet-lab validationfor crop protection"
  },
  {
    "objectID": "1_intro.html#short-reads-based-metabarcoding-for-pathogen-diagnostics",
    "href": "1_intro.html#short-reads-based-metabarcoding-for-pathogen-diagnostics",
    "title": "Introduction",
    "section": "Short-reads-based metabarcoding for pathogen diagnostics",
    "text": "Short-reads-based metabarcoding for pathogen diagnostics\nShort-read-based metabarcoding, typically targeting conserved genomic regions such as ITS or 16S rRNA, offers a cost-effective and scalable approach for pathogen detection in diagnostic metagenomics. It enables high-throughput profiling of complex microbial communities and has been instrumental in plant disease diagnostics and environmental monitoring. For example, metabarcoding has been used to detect rust fungi from airborne samples in western Canada, providing valuable insights into pathogen spatial distribution and seasonal dynamics (Chen et al. 2024; Chen, Radford, and Hambleton 2021). However, this approach also has important limitations. Short-read amplicons often lack sufficient resolution to discriminate closely related or cryptic pathogen species, particularly in taxonomically diverse groups like rust fungi. Primer bias and PCR amplification artifacts may skew community profiles, and taxonomic classification is constrained by reference database completeness and accuracy (Figure 3). Despite these challenges, short-read metabarcoding remains a valuable tool in biovigilance systems when combined with rigorous primer design, high-quality reference databases, and complementary molecular approaches.\n\n\n\n\n\n\nFigure 3: Advantages and Limitations of Metabarcoding in Pathogen Diagnostics."
  },
  {
    "objectID": "1_intro.html#introduction-to-aodp",
    "href": "1_intro.html#introduction-to-aodp",
    "title": "Introduction",
    "section": "Introduction to AODP",
    "text": "Introduction to AODP\nThe Automated Oligonucleotide Design Pipeline (AODP) (Zahariev et al. 2018) is an open-source software designed to identify “oligonucleotide signatures” from a reference sequence dataset (Figure 4). These are defined as subsequences that exclusively and perfectly match a specific group of sequences (Figure 5). The software then uses signature oligonucleotides to either confirm or rule out matching sequences in a query dataset, followed by performing modified Needleman–Wunsch algorithm for global alignment (Zahariev et al. 2018). AODP was specifically developed to enhance pathogen detection accuracy in short metabarcodes by identifying mutations within highly conserved marker regions (Zahariev et al. 2009; Chen, Radford, and Hambleton 2021). This capability allows for the precise discrimination of short metabarcodes (e.g., ITS sequence) down to the species level or below (Figure 6). The source code of AODP is in workshop folder aodp_v2.0_release.\n\n\n\n\n\n\nFigure 4: Simplified AODP matching algorithm.\n\n\n\n\n\n\n\n\n\nFigure 5: Signature oligonucleotides identified by AODP from a reference database.\n\n\n\n\n\n\n\n\n\nFigure 6: Distinguishing ITS metabarcodes of Tilletia indica (smut fungus, karnal bunt) and T. walkeri."
  },
  {
    "objectID": "1_intro.html#the-curated-cereal-rust-fungal-its2-reference-database",
    "href": "1_intro.html#the-curated-cereal-rust-fungal-its2-reference-database",
    "title": "Introduction",
    "section": "The curated cereal rust fungal ITS2 reference database",
    "text": "The curated cereal rust fungal ITS2 reference database\nThe CR-ITS2-refDB (Chen, Radford, and Hambleton 2021) is available in workshop folder refDBs.\n\nGenerated gradually over 15 years by Dr. S. Hambleton (Ottawa RDC, AAFC)\n521 trimmed ITS2 sequences\n69 taxa, including 41 Puccinia species or species complexes\nClade structure in species complexes reflects ITS-based phylogenies\n247 sequences from 7 key rust taxa infecting cereals and grasses\nPresented in a FASTA format similar to the general FASTA releases of the UNITE ITS databasethe\nDesigned for use with the AODP for high-accuracy pathogen identification\nAnnotated maximum likelihood (ML) tree of CR-ITS2-refDB shown in (Figure 7)\n\n\n\n\n\n\n\nFigure 7: Annotated Approximate Maximum Likelihood tree of CR-ITS2-refDB."
  },
  {
    "objectID": "3_aodp.html",
    "href": "3_aodp.html",
    "title": "Run AODP for species level classification",
    "section": "",
    "text": "Step-by-step instructions for activating your environment, running AODP, and integrating results"
  },
  {
    "objectID": "3_aodp.html#activate-conda-environment",
    "href": "3_aodp.html#activate-conda-environment",
    "title": "Run AODP for species level classification",
    "section": "Activate conda environment",
    "text": "Activate conda environment\n\n\n\n\n\n\nBASH Block\n\n\n\n\n\n# 1. (Optional) SSH into your remote server\nssh -Y ubuntu2204               # or yourname@your.remote.server\n\n# 2. Wrap in tmux to preserve the session\ntmux new -s aodp-training\n# …if disconnected:\n# ssh -Y ubuntu2204\n# tmux attach -t aodp-training\n\n# 3. Change to your working directory\ncd \"$wkdir\"\n\n# 4. List available environments and activate yours\nconda env list\nconda activate aodp-training\n\n# 5. Verify installation\nwhich aodp\naodp --help"
  },
  {
    "objectID": "3_aodp.html#run-aodp",
    "href": "3_aodp.html#run-aodp",
    "title": "Run AODP for species level classification",
    "section": "Run AODP",
    "text": "Run AODP\nTo runAODP, prepare a high-quality refDB in UNITE General Release format, here we use CR-ITS2-refDB.fasta in the refDBs folder. We will use “Pucciniales_asv.fasta” you have just created, which includes the representative sequences of all Pucciniales ASVs from the current study.\n\n\n\n\n\n\nBASH Block\n\n\n\n\n\n# Single oligo-size run\ntime aodp \\\n  --threads 8 \\\n  --match output/Pucciniales_asv.fasta \\\n  --oligo-size 16 \\\n  --match-output output/Pucciniales_asv.vs.CRITS2refDB.16.aodp \\\n  --max-homolo 0 \\\n  refDBs/CR-ITS2-refDB.fasta\n\n# Batch run over multiple oligo sizes\nfor os in 8 16 24; do\n  echo \"oligo-size = $os\"\n  time aodp \\\n    --threads 8 \\\n    --match output/Pucciniales_asv.fasta \\\n    --oligo-size \"$os\" \\\n    --match-output output/Pucciniales_asv.vs.CRITS2refDB.\"$os\".aodp \\\n    --max-homolo 0 \\\n    refDBs/CR-ITS2-refDB.fasta\ndone\n\n# 6. Inspect results\ncd output\nls -lh Pucciniales_asv.vs.CRITS2refDB*.aodp\n\n# Count and list identified Pucciniales ASVs\ngrep Pucciniales Pucciniales_asv.vs.CRITS2refDB.16.aodp \\\n  | cut -f1 \\\n  | sort -u \\\n  | tee Pucciniales_identified_asvs.txt \\\n  | wc -l\n\n# 7. (Optional) Deactivate when done\nconda deactivate"
  },
  {
    "objectID": "3_aodp.html#processing-aodp-outputs-in-r-to-obtain-taxonomic-classification",
    "href": "3_aodp.html#processing-aodp-outputs-in-r-to-obtain-taxonomic-classification",
    "title": "Run AODP for species level classification",
    "section": "Processing AODP outputs in R to obtain taxonomic classification",
    "text": "Processing AODP outputs in R to obtain taxonomic classification\nPreviously, we have demonstrated that the best precision and recall were achieved by oligo-size = 16 (Figure 1)\n\n\n\n\n\n\nFigure 1: Precision and recall of aodp matching algorithm for classifying mycotoxin-producing fungi.\n\n\n\n\n\n\n\n\n\nR Block\n\n\n\n\n# 0) Load required libraries ------------------------------------------------\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(phyloseq)\n\n# 1) Read & inspect raw AODP output ----------------------------------------\naodp_file &lt;- \"output/Pucciniales_asv.vs.CRITS2refDB.16.aodp\"\nranks     &lt;- c(\"kingdom\",\"phylum\",\"class\",\"order\",\"family\",\"genus\",\"species\",\"strain\")\n\n# 3rd quatile interspecific variation: 0.0152, \n# (1-0.0152)*100 = 98.2\nintraspecific_cutoff    &lt;- 98.2 \n\naodp &lt;- read.delim(\n  aodp_file,\n  header = FALSE,\n  col.names = c(\"ASV\",\"tax\",\"percent_identity\",\"match_length\",\n                \"ASV_length\",\"min_set\",\"largest_cluster\"),\n  stringsAsFactors = FALSE\n)\n\n# 2) Filter best hits & parse taxonomy -------------------------------------\naodp_filt &lt;- aodp %&gt;%\n  filter(tax != \"-\") %&gt;%                                 # drop no‐hits\n  mutate(\n    percent_identity = as.numeric(str_remove(percent_identity, \"%\")),        # \"xx.x%\" → numeric\n    tax     = str_remove(tax, \";$\")                       # drop trailing semicolon\n  ) %&gt;%\n  # keep only top‐hit per ASV, above your cutoff\n  group_by(ASV) %&gt;%\n  filter(percent_identity == max(percent_identity) & percent_identity &gt;= intraspecific_cutoff) %&gt;%\n  ungroup() %&gt;%\n  # split out “species|accession|desc|kingdom;…;strain”\n  separate(tax,\n           into = c(\"species1\",\"accession\",\"accession2\",\"desc\",\"taxonomy\"),\n           sep = \"\\\\|\",\n           extra = \"merge\", fill = \"right\",\n           remove = FALSE) %&gt;%\n  # turn the semicolon‐separated taxonomy into rank columns\n  mutate(taxonomy = str_remove_all(taxonomy, \"[dkpcofgst]__\")) %&gt;%\n  separate(taxonomy,\n           into = c(\"kingdom\",\"phylum\",\"class\",\"order\",\n                    \"family\",\"genus\",\"species\",\"strain\"),\n           sep = \";\",\n           fill = \"right\",\n           remove = FALSE) %&gt;%\n  select(-species1)\n\n# 3) Summarize unique values & counts per rank ----------------------------\nunique_tbl &lt;- aodp_filt %&gt;%\n  group_by(ASV, percent_identity) %&gt;%\n  summarise(\n    across(all_of(ranks),\n           ~ if (n_distinct(.x) == 1) unique(.x) else NA_character_),\n    .groups = \"drop\"\n  )\n\ncount_tbl &lt;- aodp_filt %&gt;%\n  group_by(ASV) %&gt;%\n  summarise(\n    across(all_of(ranks), n_distinct, .names = \"n_{.col}\"),\n    .groups = \"drop\"\n  )\n\nref_tbl &lt;- aodp_filt %&gt;%\n  group_by(ASV) %&gt;%\n  summarise(\n    refseq = paste(unique(tax), collapse = \",\"),\n    .groups = \"drop\"\n  )\n\n# 4) Compute LCA & rebuild full lineage -----------------------------------\nlca_tbl &lt;- unique_tbl %&gt;%\n  left_join(count_tbl, by = \"ASV\") %&gt;%\n  rowwise() %&gt;%\n  mutate(\n    lca_ix   = max(which(c_across(starts_with(\"n_\")) == 1)),\n    LCA_rank = ranks[lca_ix],\n    LCA_value = c_across(all_of(ranks))[lca_ix]\n  ) %&gt;%\n  mutate(\n    across(all_of(ranks), ~ {\n      pos &lt;- match(cur_column(), ranks)\n      if (pos &lt; lca_ix)    c_across(all_of(cur_column()))\n      else if (pos == lca_ix) LCA_value\n      else paste0(cur_column(), \"_undefined\")\n    })\n  ) %&gt;%\n  ungroup() %&gt;%\n  left_join(ref_tbl, by = \"ASV\") %&gt;%\n  rename_with(~ paste0(\"aodp.\", .x), -c(ASV, percent_identity, refseq))\n\n# 5) Identify ASVs dropped by filtering -----------------------------------\ndropped_asvs &lt;- tibble(ASV = unique(aodp$ASV)) %&gt;%\n  anti_join(lca_tbl, by = \"ASV\")\n\n# 6) Bundle & save final results ------------------------------------------\naodp_final &lt;- list(\n  assigned = as.data.frame(lca_tbl),\n  removed  = as.data.frame(dropped_asvs)\n)\n\nsaveRDS(aodp_final, \"output/aodp_final.RDS\")\n\n# Quick sanity checks\nhead(aodp_final$assigned[ , c(\"ASV\", \"aodp.species\")])\n\n                               ASV                         aodp.species\n1 01cacf96e7fa2e5878c556340e95a4fa Puccinia_coronata.VARavenaeFSPavenae\n2 03f65040eace36047cc5eb6e507e35c6         Puccinia_coronati.agrostidis\n3 05c6675f4aa67e096b63c32592fb6463            Puccinia_recondita.CladeX\n4 078d4add0e482cd30c534182c0a968d6    Puccinia_coronati.calamagrostidis\n5 07eed27dc85e519745652fb39aa4a969                 Puccinia_striiformis\n6 15a671eb88b1aa72fff8d0216e8322ae            Puccinia_graminis.CladeII\n\nhead(aodp_final$removed, 5)\n\n                               ASV\n1 4d9559ba3858a04ed426aca2a16a20c7\n2 af30d59db0971be9bf4845c2c9ffa539\n3 421e23034de1b2ba404dfcd8fef8b57d\n4 36a9adec4480a8f20b320162ae4c1559\n5 7d980b270e1ab4d7b9a407520da41ed3"
  },
  {
    "objectID": "3_aodp.html#modify-phyloseq-object-by-replace-the-species-level-classification-based-on-aodp",
    "href": "3_aodp.html#modify-phyloseq-object-by-replace-the-species-level-classification-based-on-aodp",
    "title": "Run AODP for species level classification",
    "section": "Modify phyloseq object by replace the species level classification based on AODP",
    "text": "Modify phyloseq object by replace the species level classification based on AODP\n\n\n\n\n\n\nR Block\n\n\n\n\n# 1) Load libraries ---------------------------------------------------------\nlibrary(phyloseq)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(stringr)\n\n# 2) Read in objects -------------------------------------------------------\nps_orig    &lt;- readRDS(\"output/phyloseq_rust.rds\")\naodp_final &lt;- readRDS(\"output/aodp_final.RDS\")\n\n# 3) Build new taxonomy table ---------------------------------------------\ntax_df &lt;- tax_table(ps_orig) %&gt;% \n  as.data.frame(stringsAsFactors = FALSE) %&gt;% \n  rownames_to_column(\"ASV\") %&gt;% \n  left_join(\n    aodp_final$assigned %&gt;% \n      select(ASV, aodp.family, aodp.genus, aodp.species),\n    by = \"ASV\"\n  ) %&gt;% \n  mutate(\n    # 3a) override family/genus if AODP provided\n    family = coalesce(aodp.family, family),\n    genus  = coalesce(aodp.genus,  genus),\n    # 3b) decide species: use AODP or fall back to genus_sp\n    genus_base = str_remove(genus, \"_sp$\"),\n    species    = if_else(\n      !is.na(aodp.species),\n      aodp.species,\n      paste0(genus_base, \"_sp\")\n    )\n  ) %&gt;% \n  select(kingdom, phylum, class, order, family, genus, species, ASV) %&gt;% \n  column_to_rownames(\"ASV\") %&gt;% \n  as.matrix()\n\n# 4) Swap taxonomy back into phyloseq --------------------------------------\nps_aodp &lt;- ps_orig\ntax_table(ps_aodp) &lt;- tax_table(tax_df)\n\n# 5) Sanity checks & save --------------------------------------------------\n# ensure no double “_sp_sp” artifacts\nstopifnot(!any(str_detect(tax_table(ps_aodp)[, \"species\"], \"_sp_sp\")))\n# peek at first two modified ASVs\ntax_table(ps_aodp)[aodp_final$assigned$ASV[1:2], ]\n\nTaxonomy Table:     [2 taxa by 7 taxonomic ranks]:\n                                 kingdom phylum          class            \n01cacf96e7fa2e5878c556340e95a4fa \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n03f65040eace36047cc5eb6e507e35c6 \"Fungi\" \"Basidiomycota\" \"Pucciniomycetes\"\n                                 order         family         genus     \n01cacf96e7fa2e5878c556340e95a4fa \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n03f65040eace36047cc5eb6e507e35c6 \"Pucciniales\" \"Pucciniaceae\" \"Puccinia\"\n                                 species                               \n01cacf96e7fa2e5878c556340e95a4fa \"Puccinia_coronata.VARavenaeFSPavenae\"\n03f65040eace36047cc5eb6e507e35c6 \"Puccinia_coronati.agrostidis\"        \n\nsaveRDS(ps_aodp, \"output/phyloseq_rust_aodp.rds\")"
  }
]